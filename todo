* some kind of macros as an alternative to auto conversion
* convert when assigning to typed locations
- architecture of real implementation
-------------------------------------------------------------------------------

fixes
* fix method cache bug
* fix ctranspose
- provide default unique generic type parameters if none given
* for conversions, make generic parameters present in destination type
  available in the function body
- only skip generic matching if an existing method matches exactly
- update wiki
-------------------------------------------------------------------------------

features
* f(x) = x syntax
* write up module design ideas
- switch open type parameters to TypeVars
- next_method
- common_supertype
- improve the situation with numeric literals somehow

- where clauses
? allow chains of conversions
? extend search space used by (conform )
  . conform (Rational[Int32],Float64) (Complex[`T],Complex[`T])
? coerce()
-------------------------------------------------------------------------------

speculation
* i wish we could write an elementwise() macro to generate operators
- complex number syntax?
- declaring abstract types
- a type with plain-old-data fields can be treated as a value type if it
  is immutable. a mutable value type is just a thing that's allowed to behave
  confusingly. the immutability is key, "value type" is an optimization
  the user doesn't have to worry about.
  to handle immutable-element-in-mutable-container, we need a special meaning
  for "a[i].re = x". it means a[i] = complex(x, a[i].im)...
  most plausible implementation is to translate it to
  a[i] = setfield(a[i], 're, x)
  and have setfield copy value types

- recursive types (tree.j) are too verbose. we should be able to say something
  like:
  type EmptyTree = ()
  type Tree[`T] = Union[EmptyTree, (data=T,left=Tree[T],right=Tree[T])]

syntax idea:

typeunion Tree[T]
  struct EmptyTree
  end

  struct TreeNode[T]
    data::T
    left::Tree[T]
    right::Tree[T]
  end
end

Much better way to do recursive types without fiddly syntax!!
Means the exact same thing as what we have now in tree.j with Union(),
except permits the required nesting!

- maybe make everything invariant, use where-clauses instead
  where-clauses create a constraint environment, sufficient to
  express "field types". For example
  Array[dims, data] where dims<:Buffer[Size], data<:Buffer

- implicit constructors instead of needing to define boilerplate functions
  like complex() and rational()
- explicit different kinds of types. e.g. StructType, NumericType
  . conceptually helpful, because you can only use new(T,...) on struct types.
    new(Int8) doesn't work, and new(Symbol) doesn't work...
- use {} for type parameters, e.g. Complex{Float64}

-------------------------------------------------------------------------------

a perpetual question is "where do objects come from?"
there are two views: user-defined constructors (C++,java,etc.), and builtin
functions (C,scheme,matlab,etc.)

constructor view:
. there is a hook to run code every time a type is instantiated
. you can have uninitialized instances
. the "actual" allocation routine is hidden, and the special form "new" is
  used. "new T()" means roughly
    x = magic_allocate<T>()
    call T's constructor with this==x
    return x
. constructor is "inside" the type, so type parameters naturally and easily
  parameterize the constructor as well.

function view:
. the magic_allocate function is exposed, anybody can make any object
. our new(T,...) forces you to provide values of correct types for all
  fields, eliminating null references ("RAII")
. consistent with our design of not encapsulating functions with types
. BUT no way to enforce invariants other than field types. for example
  you can make an Array where the dims is the wrong length!

C++-style constructor is actually an initializer; it doesn't return a value.

if we have constructors that return values, they might return nonsense.

if not, we need special syntax like new, and to magically deliver the
actual object to the constructor. but how to enforce that it gets
initialized? do we require DFA to show that all fields are set and none
are accessed before being set? this constrains the programming style.

-------------------------------------------------------------------------------

conversion/dispatch test cases:

1+rational(1,2)
rational(1,2)+0.5
1./complex(2.,2.)
1/complex(2.,2.)

-------------------------------------------------------------------------------

notes from "Using category theory to design implicit conversions and
generic operators"

conversions must commute:
OP(convert(x,T),convert(y,T)) == convert(OP(x,y),T)
if A->B and B->C, then A->C must be the composition of these two conversions

define operators for "key sorts", like (int,int) (real,real) and let
conversions handle the rest (this was our idea too!)

"one can never use the same operator for the equality relation on different
data types when the data types are connected by an implicit conversion
function which is not an injection"

-------------------------------------------------------------------------------

functions needed to port colorimetry library:

construct matrix,vector from scalars
persistent constant matrices
1d,2d scalar indexing
2d indexing with colon
elementwise mat,vec ops
matrix multiply
dot product
min,max
transpose
1d comprehension
-------------------------------------------------------------------------------

invariance vs. covariance

what does Array[Number] mean in various contexts?

new(Array[Number,n],...)
make an array that can hold various kinds of numbers, but only numbers

as a typed location, e.g. "local x::Array[Number]"
doesn't really matter. both the user & compiler don't know exactly
what kind of numbers will come out of there. user doesn't care whether
it is actually an Array[Float64], etc., but compiler does.

matching argument types, foo(x::Array[Number])
would you want to write a function just for arrays created with element
type number? sometimes a function works differently on cell arrays vs.
numeric arrays. do you need to ensure that foo(x::Array[Any]) is only
called on an actual cell array, or would it be ok to substitute any
sort of array?

with invariance, you can express this. only actual cell arrays will match.
otherwise you can write Array[T <: Any], Array[T <: Number], etc.
under covariance, the compiler effectively treats Array[Any] as Array[T]
because it needs to specialize it anyway.

-------------------------------------------------------------------------------

paper/thesis ideas:

design recommendations for technical computing languages

the design and implementation of julia

reinventing the repl: language support for interactive use

improving numeric type systems

eliminating array allocations in loops

-------------------------------------------------------------------------------

implementation plan:

* set up core types
- define all builtin types
? hash consing types
- print for primitive types
- lambda-info struct, currently the lambda expression in calls to new_closure
- be able to call julia-parser.scm
- real versions of scm->julia and julia->scm
- interface for querying environment/modules and fetching ASTs so various
  passes can still be written in scheme
- start code generation

schedule:

v0.1
Goal: Release first non-prototype implementation to friends 4/2/2010.
goals for Weeks ending
2/5:  base type constructors and object model in C (scheme lines 1-296)
2/12: type instantiation, subtype, conform predicates (lines 296-582)
2/19: method table, generic function (lines 582-798)
2/26: simple builtins (lines 798-907,1079-1269)
3/5:  scm parser/frontend interface, print, RPL (read-print loop)
3/12: finish parser interface, start llvm interface
3/19: llvm bootcamp and experiments
3/26: code generation (for the dynamic subset of the language)
4/2:  more code generation work, fixes

the last 3 weeks are the riskiest, and likely to slip by a week or two

for the next release we add the remaining critical features:

v0.2 - estimate 7/1/2010 or 8/1/2010
- begin testing and benchmarking
- modules
- optional and keyword args
- get indexing and array comprehensions fully in shape
- begin type inference, inlining, and unboxing optimizations
- simple task-parallel computing
- exceptions

v0.5 - estimate 10/1/2010
- more optimizations
- get as many as possible of the 184 important functions
- work on errors and robustness
- more parallelism

v1.0 - 2/1/2011 or before, in time for 18.337!
- more parallelism

-------------------------------------------------------------------------------

function representation
-----------------------

new functions are created in many ways:
- new (empty) generic function
- copy closure
- adding a template method to a generic function
  . any function can have static parameters, but automatic
    instantiation based on argument types is done by generic functions
- creating a new specialization inside a generic function.
  . type-specific (non-template) method is added manually by the user,
    compiled on first call
  . a more general method matches, compile for new types
  . a template method matches; apply static lambda and compile
  . *** We need a way to create the generic function and cache all
    generated code for an inner function only once, but still be able to
    add new closure environments.

  important optimization: sharing generated code for generic inner functions
  . must lift generic method creation to the top level, then when
    we enter the enclosing function, shallow copy the GF and replace
    all the closure environments with new ones. hard case is when an
    inner function has multiple definitions, each one needs a different
    closure environment. or we could combine all definitions for
    inner functions into a single one (since we can see the full set of
    definitions statically), and have a special inner-generic-function
    that can share an entire method table. on each call to the encl.
    function we just make a new IGF object with a new cloenv, and the IGF
    passes this cloenv onto any method that's actually invoked.

  . for now we will just have to make a new GF on each call to the enclosing
    function

closure ::=
    <
    type tag - a function type
    code pointer
    closure data
    static data
    >

new_closure copies this, with new closure data field

static data ::=
    <
    name
    AST
    static parameter env
    >


a GF looks like <Any-->Any, apply_generic, (methtable,), ()>

in the "let over lambda" case, a top-level GF method might have a closure
environment.

(lambda args (var-info (locals ...) vinfo-list capt-list static-params)
             #(body statements))

so in the interpreter the static parameters are inside the AST, but no
big deal.
