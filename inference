execution-based algorithm for computing maximum fixed-point solution to a DFP

Input: data-flow problem (DFP) (P, L, exec⟦code⟧(state), a₀)
       where P = I[0]..I[n], L = 〈A,⊓,⊔〉

       this is (program, lattice, language, initial_state)
       where a lattice is a value domain with meet and join operators

Output: s[0]..s[n] ∈ A
        where each s[i] gives the lattice bounds for all variables, at
          that point in the program
        s[0:n, 1:nvars, 0:1]  (3rd dim is lower/upper)

s[0] := a₀
for i := 1 to n do s[i,:,upper] := ⊤, s[i,:,lower] := ⊥
W := {0,...,n}
while W ≠ ∅ do
  choose pc ∈ W
  repeat
    W := W - pc
    new := exec⟦I[pc]⟧(s[pc])
    if I[pc] = (goto l) then pc' := l
    else
      pc' := pc+1
      if I[pc] = (if ψ goto l) and new ⊲ s[l] then
         W := W + l
 	 s[l] := update(s[l], new)
      end
    end
    if new ⊲ s[pc'] then
       s[pc'] := update(s[pc'], new)
       pc := pc'
    else
       pc := n + 1
    end
  until pc = n+1
end

final type assignment for variable v is fold(⊔, ⊥, { s[i,v] | i=0..n })

in the original algorithm:

define  new⊲s = (new ⊓ s == new) ∧ (new ≠ s)
define  update(s, new) = new

possible alternate for type inference:

define  new⊲s = (new ≠ s)
define  update(s, new) = s ⊓ new

or  update(s, new) = {U=(s[U] ⊓ new[U]), L=(s[L] ⊓ new[L]) ⊓ s[U]}

define exec⟦z := f(x,y)⟧(s[v,UL]) =
  s' = s
  s'[z,U] = tf⟦f⟧(s[x,U], s[y,U]) ⊓ s[z,U]
  s'[z,L] = tf⟦f⟧(s[x,L], s[y,L]) ⊓ s[z,U]
  return s'
end

where tf⟦f⟧ is the t-function for f


from NTI algorithm:

s[U] = (join all successor upper bounds) ⊓ s[U]
s[L] = (join all successor lower bounds) ⊓ s[U]

F = diagonal matrix of functions, Fii = exec⟦I[i]⟧, off-diag Fij = ⊥
C = square matrix, Cij = (I[j] is a successor to I[i])
S = vector of states, S[i] = {type assignments for all variables}
B = like F but using backward t-functions

find the limit of (F*C)^n * S

complete algorithm:

U := ⊤;
repeat {
  oldU := U;
  L := ⊥; repeat {oldL := L; L := (F*C*L) meet U} until L=oldL;
  U := L;
  L := ⊥; repeat {oldL := L; L := (C^t*B*L) meet U} until L=oldL;
  U := L; } until U=oldU;
