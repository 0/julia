               _      
   _       _ _(_)_     |
  (_)     | (_) (_)    | A fresh approach to technical computing 
   _ _   _| |_  __ _   | 
  | | | | | | |/ _` |  | 
  | | |_| | | | (_| |  | Web: https://github.com/JuliaLang/julia
 _/ |\__'_|_|_|\__'_|  | Mailing list: julia-math@googlegroups.com
|__/                   |

Scientific computing has traditionally required the highest performance,
yet domain experts have largely moved to slower dynamic languages for
daily work. We believe there are many good reasons to prefer dynamic languages
for these applications, and we don't expect their use to diminish any time
soon. Fortunately, modern language design and compiler techniques make it
possible to mostly eliminate the performance trade-off and provide a
single environment productive enough for prototyping and performant enough
for deploying applications. However, an open-source language with these
characteristics has not emerged. Our project, Julia, fills this gap.

MATLAB generally dominates the field of programming languages for the
applied sciences. We take note of some of the reasons for its success:
it is well-suited to linear algebra and array manipulation, easy to use, and
achieves impressive performance due to a JIT compiler (introduced in 2003).
Several open source systems (Python/NumPy, R, Octave, SciLab) offer comparable
advantages, but in particular have not kept up in the last category.

Closing this performance gap is a primary goal of ours, but at the same time
we feel there is room to increase power, flexibility, and simplicity.
The rising importance of parallel computing and cloud computing provides
further motivation to design a new system with those concerns in mind from
the beginning.

Julia is designed around a flexible type system. Programs, in general,
deal with values of widely varying disjoint types: functions, numbers,
lists, network sockets, etc. Type systems are good at sorting out
values of these different types. However, in mathematical codes, most
values are numbers. Numerical properties (such as positive, negative,
even, odd, greater than 1, etc.) are what matter, and these are highly
dynamic. The lattices involved are generally not of finite height.

Different number representations exist only for efficiency, and are
often incidental to the meaning of a piece of code. For example people
want "y = sqrt(x)" to compute the square root of x whether it is
positive or negative, and give a real or complex result
accordingly. As another example, in many cases it is convenient not to
need to worry about integer overflow. Multiple common features
underlie mathematical objects of different types (e.g. numbers, sets,
matrices). In some cases, it makes sense to consider numbers and
matrices as the same kind of thing, and in other cases it doesn't
matter. A given type system is likely not to have anticipated the
particular common features that matter to your program, making it more
difficult to express an idea. 

Julia is a very high level dynamic language with good performance,
implemented as a JIT compiler using the LLVM toolchain that lets the
system adapt to run-time conditions better. Advantages of julia over
other comparable systems are as follows:

- Consistent and powerful generic function model
- High performance
- Better performance for user-defined types
- Low syntactic overhead to define new types
- Redefinable low-level behavior
- High-level constructs for parallelism
- Free and open source
- Multi-dimensional array comprehensions
- Rich type system
- Better handling of numeric types
- More floating point types
- Cleaner syntax
- Macros
- Powerful shell-like capabilities for managing other processes
