=head1 The Julia Programming Language

Scientific computing has traditionally required the highest performance, yet domain experts have largely moved to slower dynamic languages for daily work.
We believe there are many good reasons to prefer dynamic languages for these applications, and we don't expect their use to diminish any time soon.
Fortunately, modern language design and compiler techniques make it possible to mostly eliminate the performance trade-off and provide a single environment productive enough for prototyping and performant enough for deploying applications.
However, an open-source language with these characteristics has not emerged.
Our project, Julia, fills this gap.

The syntax of Julia is directly derived from Matlab, and as a consequence, any Matlab programmer should feel immediately comfortable with Julia.
While Matlab is quite effective for prototyping and exploring numerical linear algebra, for programming tasks outside of this relatively narrow scope, Matlab has severe limitations.
Julia maintains the ease and expressiveness of Matlab for high-level numerical computing, but transcends its general programming limitations.
To that end, it borrows heavily from the C programming language.
It is additionally strongly influenced, conceptually, if not syntactically, by the lineage of dynamic programming languages:
Lisp, Perl, Python and Ruby.

=head2 Getting Started

=head3 How to Obtain and Install Julia

=head3 Running Code

Here's how you start and interact with the Julia read-eval-print loop (repl):


  $ julia
                 _      
     _       _ _(_)_     |
    (_)     | (_) (_)    |  
     _ _   _| |_  __ _   |
    | | | | | | |/ _` |  |
    | | |_| | | | (_| |  |  2009-2010 contributors
   _/ |\__'_|_|_|\__'_|  |  
  |__/                   |

  julia> 1+2
  3

  julia> load("file.j")
  ()

The C<load> function reads and evaluates the contents of the given file.

=head2 Numbers and Arithmetic

Julia supports a broad range of numeric types together with the full complement of arithmetic and bitwise operations.
The following are Julia's built-in primitive numeric types:

=over

=item integer types

=over

=item C<Int8>

signed 8-bit integers ranging from $-2^7$ to $2^7-1$.

=item C<Uint8>

unsigned 8-bit integers ranging from 0 to $2^8-1$.

=item C<Int16>

signed 16-bit integers ranging from $-2^{15}$ to $2^{15}-1$.

=item C<Uint16>

unsigned 16-bit integers ranging from 0 to $2^{16}-1$.

=item C<Int32>

signed 32-bit integers ranging from $-2^{31}$ to $2^{31}-1$.

=item C<Uint32>

unsigned 32-bit integers ranging from 0 to $2^{32}-1$.

=item C<Int64>

signed 64-bit integers ranging from $-2^{63}$ to $2^{63}-1$.

=item C<Uint64>

unsigned 64-bit integers ranging from 0 to $2^{64}-1$.

=back

=item floating point types

=over

=item C<Float32>

IEEE 754 32-bit floating point numbers.

=item C<Float64>

IEEE 754 64-bit floating point numbers.

=back

=back

=head3 Integer Literals

The default type for an integer literal is C<Int32>:

  julia> typeof(1)
  Int32

Larger integer literals that cannot be represented in 32 bits but can be represented in 64 bits will create 64-bit integers:

  julia> typeof(4294967296)
  Int64

Integers can be input in hexadecimal form using the C<0x> prefix as in C:

  julia> 0xff
  255

  julia> typeof(ans)
  Int32

  julia> 0xffffffff
  4294967295

  julia> typeof(ans)
  Int64

There is no literal input format for integer types other than C<Int32> and C<Int64>. You can, however convert C<Int32> and C<Int64> values to other types easily:

  julia> int8(-15)
  -15

  julia> typeof(ans)
  Int8

  julia> uint8(231)
  231

  julia> typeof(ans)
  Uint8

=head3 Floating Point Literals

Floating point numbers are input in the standard formats:

  julia> 1.0
  1.0

  julia> 1.
  1.0

  julia> 0.5
  0.5

  julia> .5
  0.5

  julia> -1.23
  -1.23

  julia> 1e10
  1e+10

  julia> 1e-4
  0.0001

The above results are all C<Float64> values. There is no literal format for C<Float32>, but you can convert values to C<Float32> easily:

  julia> float32(-1.5)
  -1.5

  julia> typeof(ans)
  Float32

=head3 Arithmetic and Bitwise Operations

The following arithmetic and bitwise operations are supported on built-in arithmetic types:

=over

=item arithmetic operations (integer and floating point)

=over

=item C<+x>

unary plus is the identity.

=item C<-x>

unary minus maps values to their additive inverses.

=item C<x + y>

plus performs addition.

=item C<x - y>

binary minus performs subtraction.

=item C<x * y>

times performs multiplication.

=item C<x / y>

divide performs division.

=back

=item bitwise operations (integer only)

=over

=item C<~x>

bitwise not.

=item C<x & y>

bitwise and.

=item C<x | y>

bitwise or.

=item C<x $ y>

bitwise xor.

=back

=back

Here are some simple examples:

  julia> 1+2+3
  6

  julia> 1-2
  -1

  julia> 3*2/12
  0.5

Julia has a powerful and flexible type promotion system that allows arithmetic operations on mixtures of argument types to work naturally:

  julia> 1+2.5
  3.5

  julia> 0.5*12
  6.0

  julia> 3*2/12+1
  1.5

The above operations all promote to C<Float64>s since that is the smallest floating point type that can faithfully represent all C<Int32> values.
However, more nuanced promotions also work:

  julia> uint8(12) - int8(15)
  -3

  julia> typeof(ans)
  Int16

  julia> uint8(12) - float32(1.5)
  10.5

  julia> typeof(ans)
  Float32

Here are some examples with bitwise operations:

  julia> ~123
  -124

  julia> ~uint32(123)
  4294967172

  julia> ~uint8(123)
  132

  julia> 123 & 234
  106

  julia> 123 | 234
  251

  julia> typeof(ans)
  Int32

  julia> uint8(123) | uint16(234)
  251

  julia> typeof(ans)
  Uint16

  julia> 123 $ 234
  145

As a general rule of thumb, arguments are promoted to the smallest type that can accurately represent all of the arguments. See \Section{conversion-and-promotion} for further details.

=head3 Numeric Comparisons

Standard comparison operations are defined for primitive numeric types:

=over

=item C<< == >>

equality.

=item C<< != >>

inequality.

=item C<< < >>

less than.

=item C<< <= >>

less than or equal to.

=item C<< > >>

greater than.

=item C<< >= >>

greater than or equal to.

=back

Here are some simple examples:

  julia> 1 == 1
  true

  julia> 1 == 2
  false

  julia> 1 != 2
  true
  
  julia> 1 == 1.0
  true

  julia> 1 < 2
  true

  julia> 1.0 > 3
  false

  julia> 1 >= 1.0
  true

  julia> -1 <= 1
  true

  julia> -1 <= -1
  true

  julia> -1 <= -2
  false

  julia> 3 < -0.5
  false

As you can see, promotion also applies to comparisons:
the comparisons are performed in whatever type the arguments are promoted to, which is generally the smallest type they can all be represented faithfully in.

After promotion to a common type, integers are compared in the standard manner:
by comparison of bits.
Floating point numbers are compared according to the IEEE 754 standard:
finite numbers are compared bitwise and given their usual ordering;
positive infinite values are equal to each other and greater than everything else besides C<NaN>;
negative infinite values are equal to each other and less then everything else besides C<NaN>;
all comparisons with C<NaN>s values are false, including equality with itself:

  julia> NaN == NaN
  false

For situations where one wants to compare floating point values in such a way that C<NaN == NaN>, e.g. hash key comparisons, the function C<isequal> is also provided, which considers C<NaN>s to be equal:

  julia> isequal(NaN,NaN)
  true

Unlike most languages, comparisons can be arbitrarily chained:

  julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
  true

Chaining comparisons is quite convenient in many numerical codes.

=head3 Rational Numbers

There is a special input syntax for rational numbers in Julia:

  julia> 2//3
  2//3

  julia> typeof(ans)
  Rational{Int32}

Footnote: It's actually not that special: the C<//> operator exists a priori, but its meaning of constructing rational numbers is defined entirely in the language itself.

The type of a rational number is a parametric type, a concept which is explained in detail later on in \Section{struct-constructors}.
For the moment, it suffices to explain that C<2//3> is a ratio of C<Int32> values.
If you construct a C<Rational> from values that are not in lowest terms, they will be normalized to lowest terms:

  julia> 6//9
  2//3

  julia> -4//8
  -1//2

  julia> 5//-15
  -1//3

  julia> -4//-12
  1//3

All arithmetic operations are also defined on C<Rational>s:

  julia> 2//4 + 1//6
  2//3

  julia> 5//12 - 1//4
  1//6

  julia> 5//8 * 3//12
  5//32

  julia> (6//5) / (10//7)
  21//25

TODO: fix example once precedence is fixed.

C<Rational>s can be easily converted to floating point numbers:

  julia> float(3//4)
  0.75

All such conversions obey the following identity for all integral C<a> and C<b>:

  julia> isequal(float(a//b), a/b)
  true

This includes cases where C<a == 0> or C<b == 0>, in which cases the conversion from rational to float produces the appropriate C<Â±Inf> or C<NaN> value.

  julia> 5//0
  1//0

  julia> float(5//0)
  Inf

  julia> isequal(float(5//0),5/0)
  true

  julia> 0//0
  0//0

  julia> float(0//0)
  NaN

  julia> isequal(float(0//0),0/0)
  true

  julia> -3//0
  -1//0

  julia> float(-3//0)
  -Inf

  julia> isequal(float(-3//0),-3/0)
  true

In a sense, Julia C<Rational>s are a convenient way of deferring the computation of integer ratios, thereby avoiding floating point errors.

=head2 Defining Functions

=head3 Syntax

=head3 Control Flow

=head3 Specializing Functions for Given Types

=head3 Functional Equivalents of Operators

=head3 Anonymous Functions

=head3 Returning Multiple Values

=head3 Varargs Functions

=head2 Defining Types

=head3 Tag Types

=head3 Struct Types

Julia comes with pre-defined rational and complex numeric types, but they are just defined in the language in terms of the more basic numeric types given above using the standard facility for defining new types. For example, the declaration of the C<Rational> type is the following:

  struct Rational{T<:Int} <: Real
    num::T
    den::T
  end

A few facts are in order before you can understand this declaration:

=over

=item

A C<struct> type is a named bundle of fields as in the C language. In this case the fields are C<num> and C<den> which are used to store the numerator and the denominator, respectively, of a rational number.

=item

The C<Rational{T}> syntax is used for parametric types. This declaration defines C<Rational> with respect to a type parameter, C<T>.

=item

The C<<:> operator asserts that the value on the left is a subtype of the value on the right. In this case it is used twice:

=over

=item

to assert that the type parameter, C<T>, is a subtype of C<Int>, which includes all of the above integer types;

=item

to assert that C<Rational> itself is a subtype of C<Real>, which includes the integer and floating-point types as well.

=back

=item

The C<::> operator asserts that the name on the left will always be bound to a value of the type on the right. Thus whatever the parameter C<T> is given as, the numerator and denominator of the rational number must be of that type.

=back

This is all somewhat complicated, but the result is easy to use:

  julia> Rational(1,2)
  1//2

  julia> typeof(ans)
  Rational{Int32}

Applying the C<Rational> type to a pair of values (1,2) creates a C<Rational> with those values bound to the num and den fields. The output notation 1//2 is also acceptable as input notation:

  julia> 1//2
  1//2

In fact, it is preferred because C<Rational> directly constructs a Rational number, while the C<//> form puts it into lowest terms first:

  julia> Rational(2,4)
  2//4

  julia> 2//4
  1//2

  julia> Rational(2,-3)
  2//-3

  julia> 2//-3
  -2//3

  julia> Rational(-3,-9)
  -3//-9

  julia> -3//-9
  1//3

The C<Rational> form is retained to give you the ability to construct C<Rational>s with arbitrary numerators and denominators should you care to do so. Operations on C<Rational>s are smart enough to handle this gracefully:

  julia> Rational(2,4) == Rational(1,2)
  true

Despite being effectively user-defined types, C<Rational> values interoperate completely transparently with other numeric types:

  julia> 1//2 + 2
  5//2

  julia> 1//2 + 1.5
  2.0

If you want to create an ``exotic'' rational object of a type like C<Rational{Uint8}> all you need to do is use C<Uint8> values to construct them:

  julia> uint8(123)//uint8(234)
  41//78

  julia> typeof(ans)
  Rational{Uint8}

If you use mixed types to construct a C<Rational>, the same promotions that are used for arithmetic apply:

  julia> uint8(123)//int8(-12)
  -41//4

  julia> typeof(ans)
  Rational{Int16}

=head3 Struct Constructors

=head3 Bits Types

=head3 Conversion and Promotion

=head3 Other Kinds of Types

=head2 Tensors and Comprehensions

=head2 Strings

=head2 I/O

=head2 Data Structures

=head3 Hash Tables

=head3 Sets

=head3 Queues and Dequeues

=head3 Trees

=head3 Lists

=head2 Parallel Computing

=head2 C Interface

=head2 Shell Interface

=head2 Macros

=head2 Julia Command-Line Options
