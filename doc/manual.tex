\documentclass{article}

\newcommand{\thetitle}{The Julia Programming Language}

\usepackage{amsmath}
\usepackage[hyperfigures,bookmarks,bookmarksopen,bookmarksnumbered,colorlinks,linkcolor=black,citecolor=black,filecolor=blue,menucolor=black,pagecolor=blue,frenchlinks=true,pdftitle={\thetitle}]{hyperref}

\title{\thetitle}
\author{
Jeff Bezanson \vspace{0.5em}\\
Stefan Karpinski \vspace{0.5em}\\
Viral Shah \vspace{0.5em}
}

\renewcommand{\sec}[1]{\label{sec:#1}}
\newcommand{\fig}[1]{\label{fig:#1}}
\newcommand{\tab}[1]{\label{tab:#1}}

\newcommand{\Section}[1]{\hyperref[sec:#1]{Section~\ref*{sec:#1}}}
\newcommand{\Figure}[1]{\hyperref[fig:#1]{Figure~\ref*{fig:#1}}}
\newcommand{\Table}[1]{\hyperref[tab:#1]{Table~\ref*{tab:#1}}}

\renewcommand{\bullet}{{$\diamond$}}
\renewcommand{\labelitemi}{\bullet}
\renewcommand{\labelitemii}{\bullet}
\renewcommand{\labelitemiii}{\bullet}

\begin{document}

\maketitle

Scientific computing has traditionally required the highest performance, yet domain experts have largely moved to slower dynamic languages for daily work.
We believe there are many good reasons to prefer dynamic languages for these applications, and we don't expect their use to diminish any time soon.
Fortunately, modern language design and compiler techniques make it possible to mostly eliminate the performance trade-off and provide a single environment productive enough for prototyping and performant enough for deploying applications.
However, an open-source language with these characteristics has not emerged.
Our project, Julia, fills this gap.

The syntax of Julia is directly derived from Matlab, and as a consequence, any Matlab programmer should feel immediately comfortable with Julia.
While Matlab is quite effective for prototyping and exploring numerical linear algebra, for programming tasks outside of this relatively narrow scope, Matlab has severe limitations.
Julia maintains the ease and expressiveness of Matlab for high-level numerical computing, but transcends its general programming limitations.
To that end, it borrows heavily from the C programming language.
It is additionally strongly influenced, conceptually, if not syntactically, by the lineage of dynamic programming languages:
Lisp, Perl, Python and Ruby.

\section{Getting Started}
\sec{getting-started}

\subsection{How to Obtain and Install Julia}
\sec{obtaining-and-installing}

\subsection{Running Code}
\sec{running-code}

Here's how you start and interact with the Julia read-eval-print loop (repl):

\begin{verbatim}
  $ julia
                 _      
     _       _ _(_)_     |
    (_)     | (_) (_)    |  
     _ _   _| |_  __ _   |
    | | | | | | |/ _` |  |
    | | |_| | | | (_| |  |  2009-2010 contributors
   _/ |\__'_|_|_|\__'_|  |  
  |__/                   |

  julia> 1+2
  3

  julia> load("file.j")
  ()
\end{verbatim}
The \verb|load| function reads and evaluates the contents of the given file.
The \verb|julia| program takes a variety of command-line options, similar to the \verb|perl| and \verb|ruby| programs.
See \Section{command-line-options} for details.

\section{Numbers and Arithmetic}
Julia supports a broad range of numeric types together with the full complement of arithmetic and bitwise operations.
The following are Julia's built-in primitive numeric types:

\begin{itemize}
  \item integer types:
  \begin{itemize}
    \item \verb|Int8|~: signed 8-bit integers ranging from $-2^7$ to $2^7-1$.
    \item \verb|Uint8|~: unsigned 8-bit integers ranging from 0 to $2^8-1$.
    \item \verb|Int16|~: signed 16-bit integers ranging from $-2^{15}$ to $2^{15}-1$.
    \item \verb|Uint16|~: unsigned 16-bit integers ranging from 0 to $2^{16}-1$.
    \item \verb|Int32|~: signed 32-bit integers ranging from $-2^{31}$ to $2^{31}-1$.
    \item \verb|Uint32|~: unsigned 32-bit integers ranging from 0 to $2^{32}-1$.
    \item \verb|Int64|~: signed 64-bit integers ranging from $-2^{63}$ to $2^{63}-1$.
    \item \verb|Uint64|~: unsigned 64-bit integers ranging from 0 to $2^{64}-1$.
  \end{itemize}
  \item floating point types:
  \begin{itemize}
    \item \verb|Float32|~: IEEE 754 32-bit floating point numbers.
    \item \verb|Float64|~: IEEE 754 64-bit floating point numbers.
  \end{itemize}
\end{itemize}

\subsection{Integer Literals}

The default type for an integer literal is \verb|Int32|:
\begin{verbatim}
  julia> typeof(1)
  Int32
\end{verbatim}
Larger integer literals that cannot be represented in 32 bits but can be represented in 64 bits will create 64-bit integers:
\begin{verbatim}
  julia> typeof(4294967296)
  Int64
\end{verbatim}
Integers can be input in hexadecimal form using the \verb|0x| prefix as in C:
\begin{verbatim}
  julia> 0xff
  255

  julia> typeof(ans)
  Int32

  julia> 0xffffffff
  4294967295

  julia> typeof(ans)
  Int64
\end{verbatim}
There is no literal input format for integer types besides \verb|Int32| and \verb|Int64|. You can, however convert \verb|Int32| and \verb|Int64| values to other types easily:
\begin{verbatim}
  julia> int8(-15)
  -15

  julia> typeof(ans)
  Int8

  julia> uint8(231)
  231

  julia> typeof(ans)
  Uint8
\end{verbatim}

\subsection{Floating Point Literals}

Floating point numbers are input in the standard formats:
\begin{verbatim}
  julia> 1.0
  1.0

  julia> 1.
  1.0

  julia> 0.5
  0.5

  julia> .5
  0.5

  julia> -1.23
  -1.23

  julia> 1e10
  1e+10

  julia> 2.5e-4
  0.00025
\end{verbatim}
The above results are all \verb|Float64| values. There is no literal format for \verb|Float32|, but you can convert values to \verb|Float32| easily:
\begin{verbatim}
  julia> float32(-1.5)
  -1.5

  julia> typeof(ans)
  Float32
\end{verbatim}
There are three specified floating point values that do not correspond to a point on the real number line: plus and minus infinity, and not-a-number (NaN).
Here are their literal input forms:
\begin{verbatim}
  julia> Inf
  Inf

  julia> -Inf
  -Inf

  julia> NaN
  NaN
\end{verbatim}
As specified by the IEEE 754 standard, these floating point values are the results of certain arithmetic operations:
\begin{verbatim}
  julia> 1/0
  Inf

  julia> -5/0
  -Inf

  julia> 0.000001/0
  Inf

  julia> 0/0
  NaN

  julia> 500 + Inf
  Inf

  julia> 500 - Inf
  -Inf

  julia> Inf - Inf
  NaN

  julia> Inf/Inf
  NaN
\end{verbatim}

\subsection{Arithmetic and Bitwise Operations}

The following arithmetic and bitwise operations are supported on built-in arithmetic types:
\begin{itemize}
  \item arithmetic operations (integer and floating point):
  \begin{itemize}
    \item \verb|+x|~: unary plus is the identity operation.
    \item \verb|-x|~: unary minus maps values to their additive inverses.
    \item \verb|x + y|~: plus performs addition.
    \item \verb|x - y|~: binary minus performs subtraction.
    \item \verb|x * y|~: times performs multiplication.
    \item \verb|x / y|~: divide performs division.
  \end{itemize}
  \item bitwise operations (integer only)\,:
  \begin{itemize}
    \item \verb|~x|~: bitwise not.
    \item \verb|x & y|~: bitwise and.
    \item \texttt{x | y}~: bitwise or.
    \item \verb|x $ y|~: bitwise xor.
  \end{itemize}
\end{itemize}
Here are some simple examples:
\begin{verbatim}
  julia> 1+2+3
  6

  julia> 1-2
  -1

  julia> 3*2/12
  0.5
\end{verbatim}
Julia has a powerful and flexible type promotion system that allows arithmetic operations on mixtures of argument types to work naturally:
\begin{verbatim}
  julia> 1+2.5
  3.5

  julia> 0.5*12
  6.0

  julia> 3*2/12+1
  1.5
\end{verbatim}
The above operations all promote to \verb|Float64|s since that is the smallest floating point type that can faithfully represent all \verb|Int32| values.
However, more nuanced promotions also work:
\begin{verbatim}
  julia> uint8(12) - int8(15)
  -3

  julia> typeof(ans)
  Int16

  julia> uint8(12) - float32(1.5)
  10.5

  julia> typeof(ans)
  Float32
\end{verbatim}
Here are some examples with bitwise operations:
\begin{verbatim}
  julia> ~123
  -124

  julia> ~uint32(123)
  4294967172

  julia> ~uint8(123)
  132

  julia> 123 & 234
  106

  julia> 123 | 234
  251

  julia> typeof(ans)
  Int32

  julia> uint8(123) | uint16(234)
  251

  julia> typeof(ans)
  Uint16

  julia> 123 $ 234
  145
\end{verbatim}
As a general rule of thumb, arguments are promoted to the smallest type that can accurately represent all of the arguments. See \Section{conversion-and-promotion} for further details.

\subsection{Numeric Literal Coefficients}

To make common numeric formulas and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication.
This makes writing polynomial expressions much cleaner:
\begin{verbatim}
  julia> x = 3
  3

  julia> 2x + 1
  7

  julia> 2x^2 - 3x + 1
  10

  julia> 1.5x^2 - .5x + 1
  13.0
\end{verbatim}
Juxtaposed numeric coefficients conflict with two numeric literal syntaxes:
hexadecimal integer literals and engineering notation for floating point literals:
\begin{itemize}
\item The hexadecimal integer literal expression \verb|0xff| could also be interpreted as the numeric literal \verb|0| multiplied by the variable \verb|xff|.
\item The floating point literal expression \verb|1e10| could also be interpreted as the numeric literal \verb|1| multiplied by the variable \verb|e10|, and likewise with \verb|E|.
\end{itemize}
In both cases, we resolve the ambiguity in favor of the numeric literals:
\begin{itemize}
\item Expressions starting with \verb|0x| are always hexadecimal literals.
\item Expressions starting with $d.dd$\,\verb|e| or $d.dd$\,\verb|E| are always floating point literals.
\end{itemize}

\subsection{Numeric Comparisons}

Standard comparison operations are defined for primitive numeric types:
\begin{itemize}
  \item \verb|==|~: equality.
  \item \verb|!=|~: inequality.
  \item \verb|<|~: less than.
  \item \verb|<=|~: less than or equal to.
  \item \verb|>|~: greater than.
  \item \verb|>=|~: greater than or equal to.
\end{itemize}
Here are some simple examples:
\begin{verbatim}
  julia> 1 == 1
  true

  julia> 1 == 2
  false

  julia> 1 != 2
  true
  
  julia> 1 == 1.0
  true

  julia> 1 < 2
  true

  julia> 1.0 > 3
  false

  julia> 1 >= 1.0
  true

  julia> -1 <= 1
  true

  julia> -1 <= -1
  true

  julia> -1 <= -2
  false

  julia> 3 < -0.5
  false
\end{verbatim}
As can be seen here, promotion also applies to comparisons:
the comparisons are performed in whatever type the arguments are promoted to, which is generally the smallest type they can all be represented faithfully in.

After promotion to a common type, integers are compared in the standard manner:
by comparison of bits.
Floating point numbers are compared according to the IEEE 754 standard:
finite numbers are compared bitwise and given their usual ordering;
positive infinite values are equal to each other and greater than everything else besides \verb|NaN|;
negative infinite values are equal to each other and less then everything else besides \verb|NaN|;
\verb|NaN| is not equal to, less than, or greater than anything, including itself:
\begin{verbatim}
  julia> NaN == NaN
  false

  julia> NaN != NaN
  true

  julia> NaN < NaN
  false

  julia> NaN > NaN
  false
\end{verbatim}
For situations where one wants to compare floating point values in such a way that \verb|NaN == NaN|, e.g. hash key comparisons, the function \verb|isequal| is also provided, which considers \verb|NaN|s to be equal:
\begin{verbatim}
  julia> isequal(NaN,NaN)
  true
\end{verbatim}
Unlike most languages, comparisons can be arbitrarily chained:
\begin{verbatim}
  julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
  true
\end{verbatim}
Chaining comparisons is quite convenient in many numerical codes.

\subsection{Rational Numbers}

There is a special\footnote{Actually, it's not that special: the \texttt{//} operator exists \emph{a priori}, but its usage for constructing rational numbers is defined entirely in the language itself.} input syntax for rational numbers in Julia:
\begin{verbatim}
  julia> 2//3
  2//3

  julia> typeof(ans)
  Rational{Int32}
\end{verbatim}
The type of a rational number is a parametric type, a concept which is explained in detail later on in \Section{struct-constructors}.
For the moment, it suffices to explain that \verb|2//3| is a ratio of \verb|Int32| values.
If you construct a \verb|Rational| from values that are not in lowest terms, they will be normalized to lowest terms:
\begin{verbatim}
  julia> 6//9
  2//3

  julia> -4//8
  -1//2

  julia> 5//-15
  -1//3

  julia> -4//-12
  1//3
\end{verbatim}
All arithmetic operations are also defined on \verb|Rational|s:
\begin{verbatim}
  julia> 2//4 + 1//6
  2//3

  julia> 5//12 - 1//4
  1//6

  julia> 5//8 * 3//12
  5//32

  julia> (6//5) / (10//7)
  21//25
\end{verbatim} % TODO: fix example once precedence is fixed.
\verb|Rational|s can be easily converted to floating point numbers:
\begin{verbatim}
  julia> float(3//4)
  0.75
\end{verbatim}
All such conversions obey the following identity for all integral \verb|a| and \verb|b|:
\begin{verbatim}
  julia> isequal(float(a//b), a/b)
  true
\end{verbatim}
This includes cases where \verb|a == 0| or \verb|b == 0|, in which situations the conversion from rational to float produces the appropriate $\pm$\verb|Inf| or \verb|NaN| value:
\begin{verbatim}
  julia> 5//0
  1//0

  julia> float(5//0)
  Inf

  julia> isequal(float(5//0), 5/0)
  true

  julia> 0//0
  0//0

  julia> float(0//0)
  NaN

  julia> isequal(float(0//0), 0/0)
  true

  julia> -3//0
  -1//0

  julia> float(-3//0)
  -Inf

  julia> isequal(float(-3//0), -3/0)
  true
\end{verbatim}
In a sense, Julia \verb|Rational|s are a convenient way of deferring the computation of integer ratios, thereby avoiding the accumulation of floating point errors.

\subsection{Complex Numbers}

\section{Control Flow}



\section{Functions}

The basic syntax for defining functions in Julia is:
\begin{verbatim}
  function f(x,y)
    x + y
  end
\end{verbatim}
This syntax is similar to Matlab, but there are some significant differences:
\begin{itemize}
\item In Matlab, this definition must be saved in a file, named \verb|f.m|.
In Julia, this expression can appear anywhere, including at the repl prompt.
\item In Matlab, the closing \verb|end| is optional, being implied by the end of the file.
In Julia, the terminating \verb|end| is required.
\item in Matlab, this function would print the value $x + y$ but not return any value.
In Julia, the last expression evaluated is a function's return value.
\item Expression values are not printed automatically except in the repl.
Semicolons are only required to separate expressions on the same line.
\end{itemize}
In general, while the function definition is reminiscent of Matlab, the similarity is largely superficial.
Rather than continually comparing the two, in what follows, we will simply describe the behavior of functions in Julia.

There is a second, more compact syntax for defining a function in Julia.
The traditional function declaration syntax demonstrated above is equivalent to the following terse form:
\begin{verbatim}
  f(x,y) = x + y
\end{verbatim}
In this short form, the body of the function must be a single expression, although it can be a complex compound expression.
Short, simple function definitions are quite common in Julia.
The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.

\subsection{The \texttt{return} Keyword}

The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition.
In the example function, \verb|f|, this is simply the value of the expression \verb|x + y|.
As in C, and most other imperative or functional languages, the \verb|return| keyword can cause the function to return from any point, optionally providing an expression whose value is returned:
\begin{verbatim}
  function g(x,y)
    return x * y
    x + y
  end
\end{verbatim}
Since functions definitions can be entered directly into the repl, it is easy to try these definitions out to compare them:
\begin{verbatim}
  julia> function g(x,y)
           return x * y
           x + y
         end
  Methods for generic function g
  g(Any,Any)

  julia> g(2,3)
  6

  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(2,3)
  5
\end{verbatim}
Of course, in a purely linear function body like \verb|g|, the usage of \verb|return| is pointless since the expression \verb|x + y| is never evaluated and we could simply make \verb|x * y| the last expression in the function and omit the \verb|return|.
In conjunction with other control flow, however, \verb|return| is of real use.
Here, for example is a function which computes the hypotenuse length of a right triangle with sides of length $x$ and $y$, carefully avoiding numerical problems in corner cases:
\begin{verbatim}
  function hypot(x,y)
      x = abs(x)
      y = abs(y)
      if x > y
          r = y/x
          return x*sqrt(1+r*r)
      end
      if y == 0
          return zero(x)
      end
      r = x/y
      return y*sqrt(1+r*r)
  end
\end{verbatim}
There are three possible points of return from this function, returning the values of three different expressions, depending on the values of $x$ and $y$.
The \verb|return| on the last line could be omitted since it is the last expression.

\subsection{Specializing Functions for Given Types}

Julia allows multiple dispatch based on the types of function arguments:
\begin{verbatim}
  f(x,y) = x + y
  f(x::Float64, y::Float64) = x * y
\end{verbatim}
The appropriate version will be called based on the types of the argument values:
\begin{verbatim}
  julia> f(2,3)
  5

  julia> f(2.0,3.0)
  6.0
\end{verbatim}
Dispatch is done on all argument types and the most specific method that applies is called:
\begin{verbatim}
  julia> f(2,3.0)
  5.0
\end{verbatim}
Here, the first method of \verb|f| is applied since \verb|2| is not a \verb|Float64|, so the specialized second method does not apply.

If you've been entering these definitions in the repl, you'll have noticed that it shows you all the methods defined for a given ``generic function'' when a new method is defined or if ask the repl to show the function object:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y::Float64) = x * y
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)

  julia> f
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)
\end{verbatim}
The \verb|Any| type is the default when no type is specified:
all Julia objects match \verb|Any|.
In formal type system literature, \verb|Any| is commonly called Top.\footnote{Julia also has a Bottom type called \texttt{None} which no object matches.}

Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language.
Core operations typically have dozens of methods defined:
\begin{verbatim}
  julia> +
  Methods for generic function +
  +(Real,Range{T<:Real})
  +(Real,Range1{T<:Real})
  +(Union(Range{T<:Real},Range1{T<:Real}),Real)
  +(Union(Range{T<:Real},Range1{T<:Real}),
    Union(Range{T<:Real},Range1{T<:Real}))
  +()
  +(Number,)
  +(Any,Any,Any)
  +(Any,Any,Any,Any)
  +(Any,Any,Any,Any,Any)
  +(Any,Any,Any,Any...)
  +(Int8,Int8)
  +(Int16,Int16)
  +(Int32,Int32)
  +(Int64,Int64)
  +(Uint8,Uint8)
  +(Uint16,Uint16)
  +(Uint32,Uint32)
  +(Uint64,Uint64)
  +(Float32,Float32)
  +(Float64,Float64)
  +(Char,Char)
  +(Rational{T<:Int},Rational{T<:Int})
  +(Complex{T<:Real},Complex{T<:Real})
  +(T<:Number,T<:Number)
  +(Number,Number)
  +(Tensor{T<:Number,N},)
  +(Tensor{S,N},Tensor{T,N})
  +(Number,Tensor{T,N})
  +(Tensor{T,N},Number)
\end{verbatim}
Multiple dispatch together with the flexible parametric type system, give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient specialized code at run time.

\subsection{Method Ambiguities}

It is possible to define a set of function methods such that ambiguous cases exist where for some combinations of argument types there is no unique most specific method which applies:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y) = 2x + y
  Methods for generic function f
  f(Float64,Any)
  f(Any,Any)

  julia> f(x, y::Float64) = x + 2y
  Warning: new definition f(Any,Float64) is ambiguous with
  f(Float64,Any). Make sure f(Float64,Float64) is also defined.
  Methods for generic function f
  f(Float64,Any)
  f(Any,Float64)
  f(Any,Any)

  julia> f(2,3)
  5

  julia> f(2.0,3)
  7.0

  julia> f(2,3.0)
  8.0

  julia> f(2.0,3.0)
  7.0
\end{verbatim}
Here the arguments \verb|2.0| and \verb|3.0| could be handled by either the \verb|f(Float64,Any)| or the \verb|f(Any,Float64)| method, and neither is more specific than the other.
In such cases, Julia warns you about this ambiguity, but allows you to proceed, arbitrarily picking a method.
You should avoid method ambiguities by specifying an appropriate method for the intersection case:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y::Float64) = 2x + 2y
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)

  julia> f(x::Float64, y) = 2x + y
  Methods for generic function f
  f(Float64,Float64)
  f(Float64,Any)
  f(Any,Any)

  julia> f(x, y::Float64) = x + 2y
  Methods for generic function f
  f(Float64,Float64)
  f(Float64,Any)
  f(Any,Float64)
  f(Any,Any)

  julia> f(2,3)
  5

  julia> f(2.0,3)
  7.0

  julia> f(2,3.0)
  8.0

  julia> f(2.0,3.0)
  10.0
\end{verbatim}
To suppress Julia's warning, the disambiguating method must be defined first.

\subsection{Functional Equivalents of Operators}
\subsection{Anonymous Functions}
\subsection{Returning Multiple Values}
\subsection{Varargs Functions}
\section{Defining Types}
\subsection{Tag Types}
\subsection{Struct Types}

Julia comes with pre-defined rational and complex numeric types, but they are just defined in the language in terms of the more basic numeric types given above using the standard facility for defining new types. For example, the declaration of the \verb|Rational| type is the following:
\begin{verbatim}
  struct Rational{T<:Int} <: Real
    num::T
    den::T
  end
\end{verbatim}
A few facts are in order before you can understand this declaration:
\begin{itemize}
\item A \verb|struct| type is a named bundle of fields as in the C language. In this case the fields are \verb|num| and \verb|den| which are used to store the numerator and the denominator, respectively, of a rational number.
\item The \verb|Rational{T}| syntax is used for parametric types. This declaration defines \verb|Rational| with respect to a type parameter, \verb|T|.
\item The \verb|<:| operator asserts that the value on the left is a subtype of the value on the right. In this case it is used twice:
  \begin{itemize}
    \item to assert that the type parameter, \verb|T|, is a subtype of \verb|Int|, which includes all of the above integer types;
    \item to assert that \verb|Rational| itself is a subtype of \verb|Real|, which includes the integer and floating-point types as well.
  \end{itemize}
\item The \verb|::| operator asserts that the name on the left will be bound to a value of the type on the right. Thus whatever type parameter \verb|T| is given as, the numerator and denominator of the rational number are of that type.
\end{itemize}
This is all somewhat complicated, but the result is easy to use:
\begin{verbatim}
  julia> Rational(1,2)
  1//2

  julia> typeof(ans)
  Rational{Int32}
\end{verbatim}
Applying the \verb|Rational| type to a pair of values (1,2) creates a \verb|Rational| with those values bound to the num and den fields. The output notation 1//2 is also acceptable as input notation:
\begin{verbatim}
  julia> 1//2
  1//2
\end{verbatim}
In fact, it is preferred because \verb|Rational| directly constructs a Rational number, while the \verb|//| form puts it into lowest terms first:
\begin{verbatim}
  julia> Rational(2,4)
  2//4

  julia> 2//4
  1//2

  julia> Rational(2,-3)
  2//-3

  julia> 2//-3
  -2//3

  julia> Rational(-3,-9)
  -3//-9

  julia> -3//-9
  1//3
\end{verbatim}
The \verb|Rational| form is retained to give you the ability to construct \verb|Rational|s with arbitrary numerators and denominators should you care to do so. Operations on \verb|Rational|s are smart enough to handle this gracefully:
\begin{verbatim}
  julia> Rational(2,4) == Rational(1,2)
  true
\end{verbatim}
Despite being effectively user-defined types, \verb|Rational| values interoperate completely transparently with other numeric types:
\begin{verbatim}
  julia> 1//2 + 2
  5//2

  julia> 1//2 + 1.5
  2.0
\end{verbatim}
If you want to create an ``exotic'' rational object of a type like \verb|Rational{Uint8}| all you need to do is use \verb|Uint8| values to construct them:
\begin{verbatim}
  julia> uint8(123)//uint8(234)
  41//78

  julia> typeof(ans)
  Rational{Uint8}
\end{verbatim}
If you use mixed types to construct a \verb|Rational|, the same promotions that are used for arithmetic apply:
\begin{verbatim}
  julia> uint8(123)//int8(-12)
  -41//4

  julia> typeof(ans)
  Rational{Int16}
\end{verbatim}

\subsection{Struct Constructors}
\sec{struct-constructors}

\subsection{Bits Types}

\subsection{Conversion and Promotion}
\sec{conversion-and-promotion}

\subsection{Other Kinds of Types}

\section{Tensors and Comprehensions}
\section{Strings}
\section{I/O}
\section{Data Structures}
\subsection{Hash Tables}
\subsection{Sets}
\subsection{Queues and Dequeues}
\subsection{Trees}
\subsection{Lists}

\section{Parallel Computing}
\section{Calling C Functions}
\section{Running External Programs}

Perl, Python, and Ruby are well known for their ability to easily run and interact with other programs.
In Perl and Ruby, backticks provide a powerful and simple way to call a program and capture its output as as a string:
\begin{verbatim}
  #!/usr/bin/env perl
  $greeting = `echo -n hello`;
  print "$greeting, world.\n";
\end{verbatim}
In this rather simplistic example, the \verb|echo| program prints the string \verb|"hello"| and that output is captured into the variable \verb|$greeting|.
Arbitrary shell commands can be spawned in backticks because backticks actually spawn a shell to interpret and run these commands.
Thus, much of the power of this approach comes from the shell---the programming language just spawns the shell and arranges to capture the output.
You can pass data to the programs spawned by interpolating values into the shell command:
\begin{verbatim}
  #!/usr/bin/env perl
  $sorted = `sort -n $file`;
\end{verbatim}
Here things become a bit dangerous:
if the value of the variable \verb|$file| contains characters that are specially interpreted by the shell, they will be.
For example, if \verb|$file| is the string \verb|"/Volumes/External HD/data.csv"|, then the above command will attempt to sort the contents of two files named \verb|/Volumes/External| and \verb|HD/data.csv|, which are likely to either not exist, or possibly worse, not be the intended files.

There are two approaches one can take to address this issue: escape all the shell metacharacters in the the string \verb|$file| before interpolating it, or avoid using the shell by calling a lower level function like \verb|exec|.
Both Perl and Ruby provide some ability to start a program and then read from its output file descriptor, but these approaches rapidly become quite cumbersome.
Shell metacharacter escaping is provided by some third party modules, but is not a standard part of the installation of any of the scripting languages, and is hard to get right:
the shell itself has a lot of complexity and syntax.
In practice, programmers calling external programs simply tend to just hope that there are no strange characters in their file names.
A few of the more paranoid will wrap arguments in single quotes within the backticks, writing \verb|`sort -n '$file'`|.
This, however, is quite ugly, annoying, and worst of all, doesn't actually fix the problem.

Julia takes the second approach:
instead of calling a shell to spawn external commands, Julia performs all the tricky UNIX pipe plumbing for you.
Moreover, it allows you to easily create pipelines \emph{in Julia} where one command pipes output to another.
In essence, Julia aims to be a better shell than the shell.
Backtick notation is retained, but in Julia it doesn't run the command immediately, but rather creates a \verb|Cmd| object:
\begin{verbatim}
  julia> cmd = `echo hello`
  `echo hello`

  julia> dump(cmd)
  Cmd(exec=("echo",("hello",)),
      pipes=HashTable(),pipeline=Set([`echo hello`]),
      pid=0,status=ProcessNotRun(),)
\end{verbatim}
The \verb|Cmd| object is a structure encoding what command to run as well as metadata about the resulting process and other related commands.
For convenience, however, it is shown in the input format.
The immediately obvious thing to do with a \verb|Cmd| object is to run it:
\begin{verbatim}
  julia> run(cmd)
  hello
  true
\end{verbatim}
The \verb|hello| part above is the output from the echo command, while the \verb|true| part is the value retuned by the \verb|run| function, indicating that all the subprocesses spawned by \verb|run| succeeded.
Here we see one advantage of spawning processes directly:
the program has access to the status of each spawned child program, thereby avoiding not only the overhead of starting a shell, but also the potential it causes for hiding programming errors.
Metadata about the completed process is retained in the \verb|cmd| object after the process completes:
\begin{verbatim}
  julia> dump(cmd)
  Cmd(exec=("echo",("hello",)),
      pipes=HashTable(),pipeline=Set([`echo hello`]),
      pid=79300,status=ProcessExited(0),)
\end{verbatim}

If you want to pass data to a program as an argument, it looks very similar to the previous example in Perl:
\begin{verbatim}
  julia> file = "/Volumes/External HD/data.csv"
  "/Volumes/External HD/data.csv"

  julia> `sort -n $file`
  `sort -n '/Volumes/External HD/data.csv'`
\end{verbatim}
Wait? How did the file argument get quoted?
The Julia backtick syntax understands both shell argument quoting \emph{and} how the arguments are interpolated.
It knows that \verb|$file| is supposed to be a single argument and correctly generates arguments to an \verb|exec| call that safely do what you intended.
When showing the \verb|Cmd| object, the output is generated so that if evaluated, it creates an equivalent command object.

The fact that the backtick syntax is intelligently integrated with the language is quite powerful.
Arrays are interpolated correctly as multiple arguments:
\begin{verbatim}
  julia> files = {
           "/Volumes/External HD/data.csv"
           "tmp/other.csv"
         }
  {"/Volumes/External HD/data.csv","tmp/other.csv"}

  julia> `sort -n $files`
  `sort -n '/Volumes/External HD/data.csv' tmp/other.csv`
\end{verbatim}
Note that this is interpolated correctly as two arguments, the first containing a space, rather than incorrectly as three arguments as it would in Perl or Ruby.
If a collection is interpolated as part of a larger command argument, Julia emulates the shell \verb|{a,b,c}| argument generation syntax:
\begin{verbatim}
  julia> names = {"foo","bar","baz"}
  {"foo","bar","baz"}

  julia> `rm -f $names.txt`
  `rm -f foo.txt bar.txt baz.txt`
\end{verbatim}
If multiple collections are interpolated into a single argument, it produces the cartesian product of their concatenations, again emulating the behavior of the shell's \verb|{a,b,c}| syntax:
\begin{verbatim}
  julia> exts = {"aux","log"}
  {"aux","log"}

  julia> `rm -f $names.$exts`
  `rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{verbatim}

Especially when calling other programming languages, it may become necessary to use spaces, escapes, or quotes.
In these matters, Julia emulates the shell:
it respects shell-style semantics for spaces, escapes, quoting, and interpolation.
In particular, variable interpolation does not occur inside of single quotes:
\begin{verbatim}
  julia> a = 9; b = 1; c = "hello";

  julia> `perl -le 'print "'$a'"; print $_ for @ARGV' $b "c: $c"`
  `perl -le 'print "9"; print $_ for @ARGV' 1 'c: hello'`

  julia> run(ans)
  9
  1
  c: hello
  true
\end{verbatim}
Here a Perl program is provided via the \verb|-e| option and is protected from interpolation by single quotes.
The \verb|$a| is interpolated, however, because the single quotes are closed and opened again;
the \verb|$_| is not interpolated because it is still protected by single quotes;
the \verb|$b| is a bare argument, and is thus interpolated, and the \verb|$c| is interpolated as part of an argument because double quotes do not prevent interpolation.
This may seem quite complex, but it is carefully designed so that you can basically just cut and paste commands from the shell and expect backticks to do the right thing, safely and correctly.

Unlike the shell, besides escapes, quotes, and spaces, no other characters are treated specially---a pipe is always just a pipe:
\begin{verbatim}
  julia> run(`echo | sort`)
  | sort
  true
\end{verbatim}
This just prints a literal pipe character and the word ``sort.''
Other shell meta-characters, like \verb|!| and \verb|&| are similarly interpreted literally.
For complex shell-like programming, you use Julia's operators to manipulate \verb|Cmd| objects instead:
\begin{verbatim}
  julia> run(`cut -d: -f3 /etc/passwd` |
             `perl -nle 'print unless /^\s*#/'` |
             `sort -n` | `head`)
  -2
  0
  1
  4
  26
  27
  54
  55
  56
  58
  true
\end{verbatim}
It's simple to run multiple programs in parallel and wait for them all to finish:
\begin{verbatim}
  julia> run(`echo hello` & `echo world`)
  world
  hello
  true
\end{verbatim}
The order of the output here is non-deterministic because the two \verb|echo| processes are started nearly simultaneously, and race make the first write to the \verb|stdout| descriptor they share with each other and with their parent \verb|julia| process.
Julia lets you pipe the output from these parallel processes to another program easily:
\begin{verbatim}
  julia> run(`echo world` & `echo hello` | `sort`)
  hello
  world
  true
\end{verbatim}
That's something you simply cannot do in the shell, and while you can do it in Perl, Python, or Ruby, it requires unpleasant and tricky mucking around with the \verb|pipe|, \verb|dup2|, \verb|fork|, and \verb|exec| system calls.

Now we're just going to showboat a bit (apologies for excessive Perlage):
\begin{verbatim}
  julia> prefixer(sleep, prefix) =
           `perl -nle '$|=1;
                       print "'$prefix' ", $_;
                       sleep '$sleep';'`
  Methods for generic function prefixer
  prefixer(Any,Any)

  julia> run(`perl -le '$|=1; for(0..9){ print; sleep 1 }'` |
             prefixer(2,"A") & prefixer(2,"B"))
  A	0
  B	1
  A	2
  B	3
  A	4
  B	5
  A	6
  B	7
  A	8
  B	9
  true

  julia> run(`perl -le '$|=1; for(0..9){ print; sleep 1 }'` |
             prefixer(3,"X") & prefixer(3,"Y") & prefixer(3,"Z") |
             prefixer(2,"A") & prefixer(2,"B"))
  B	Y	0
  A	Z	1
  B	X	2
  A	Y	3
  B	Z	4
  A	X	5
  B	Y	6
  A	Z	7
  B	X	8
  A	Y	9
  true

  julia> gen = `perl -le '$|=1; for(0..9){ print; sleep 1 }'`
  `perl -le '$|=1; for(0..9){ print; sleep 1 }'`

  julia> dup = `perl -ne '$|=1; warn $_; print ".$_"; sleep 1'`
  `perl -ne '$|=1; warn $_; print ".$_"; sleep 1'`

  julia> run(gen | dup | dup)
  0
  .0
  1
  ..0
  2
  .1
  3
  ...0
  4
  .2
  5
  ..1
  6
  .3
  ....0
  7
  .4
  8
  9
  ..2
  .5
  ...1
  .6
  ..3
  .....0
  .7
  ..4
  .8
  .9
  ...2
  ..5
  ....1
  ..6
  ...3
\end{verbatim}
The final example never terminates since the \verb|dup| process reads its own output and duplicates it to \verb|stderr| forever.

\section{Macros}

\section{Command-Line Options}
\sec{command-line-options}

\end{document}
