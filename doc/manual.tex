\documentclass{article}

\newcommand{\thetitle}{The Julia Programming Language}

\usepackage{amsmath}
\usepackage[hyperfigures,bookmarks,bookmarksopen,bookmarksnumbered,colorlinks,linkcolor=black,citecolor=black,filecolor=blue,menucolor=black,pagecolor=blue,frenchlinks=true,pdftitle={\thetitle}]{hyperref}

\title{\thetitle}
\author{
Jeff Bezanson \vspace{0.5em}\\
Stefan Karpinski \vspace{0.5em}\\
Viral Shah \vspace{0.5em}
}

\renewcommand{\sec}[1]{\label{sec:#1}}
\newcommand{\fig}[1]{\label{fig:#1}}
\newcommand{\tab}[1]{\label{tab:#1}}

\newcommand{\Section}[1]{\hyperref[sec:#1]{Section~\ref*{sec:#1}}}
\newcommand{\Figure}[1]{\hyperref[fig:#1]{Figure~\ref*{fig:#1}}}
\newcommand{\Table}[1]{\hyperref[tab:#1]{Table~\ref*{tab:#1}}}

\renewcommand{\bullet}{{$\diamond$}}
\renewcommand{\labelitemi}{\bullet}
\renewcommand{\labelitemii}{\bullet}
\renewcommand{\labelitemiii}{\bullet}

\begin{document}

\maketitle

Scientific computing has traditionally required the highest performance, yet domain experts have largely moved to slower dynamic languages for daily work.
We believe there are many good reasons to prefer dynamic languages for these applications, and we don't expect their use to diminish any time soon.
Fortunately, modern language design and compiler techniques make it possible to mostly eliminate the performance trade-off and provide a single environment productive enough for prototyping and performant enough for deploying applications.
However, an open-source language with these characteristics has not emerged.
Our project, Julia, fills this gap.

The syntax of Julia is directly derived from Matlab, and as a consequence, any Matlab programmer should feel immediately comfortable with Julia.
While Matlab is quite effective for prototyping and exploring numerical linear algebra, for programming tasks outside of this relatively narrow scope, Matlab has severe limitations.
Julia maintains the ease and expressiveness of Matlab for high-level numerical computing, but transcends its general programming limitations.
To that end, it borrows heavily from the C programming language.
It is additionally strongly influenced, conceptually, if not syntactically, by the lineage of dynamic programming languages:
Lisp, Perl, Python and Ruby.

\section{Getting Started}
\subsection{How to Obtain and Install Julia}
\subsection{Running Code}

Here's how you start and interact with the Julia read-eval-print loop (repl):

\begin{verbatim}
  $ julia
                 _      
     _       _ _(_)_     |
    (_)     | (_) (_)    |  
     _ _   _| |_  __ _   |
    | | | | | | |/ _` |  |
    | | |_| | | | (_| |  |  2009-2010 contributors
   _/ |\__'_|_|_|\__'_|  |  
  |__/                   |

  julia> 1+2
  3

  julia> load("file.j")
  ()
\end{verbatim}
The \verb|load| function reads and evaluates the contents of the given file.

\section{Numbers and Arithmetic}
Julia supports a broad range of numeric types together with the full complement of arithmetic and bitwise operations.
The following are Julia's built-in primitive numeric types:

\begin{itemize}
  \item integer types:
  \begin{itemize}
    \item \verb|Int8|~: signed 8-bit integers ranging from $-2^7$ to $2^7-1$.
    \item \verb|Uint8|~: unsigned 8-bit integers ranging from 0 to $2^8-1$.
    \item \verb|Int16|~: signed 16-bit integers ranging from $-2^{15}$ to $2^{15}-1$.
    \item \verb|Uint16|~: unsigned 16-bit integers ranging from 0 to $2^{16}-1$.
    \item \verb|Int32|~: signed 32-bit integers ranging from $-2^{31}$ to $2^{31}-1$.
    \item \verb|Uint32|~: unsigned 32-bit integers ranging from 0 to $2^{32}-1$.
    \item \verb|Int64|~: signed 64-bit integers ranging from $-2^{63}$ to $2^{63}-1$.
    \item \verb|Uint64|~: unsigned 64-bit integers ranging from 0 to $2^{64}-1$.
  \end{itemize}
  \item floating point types:
  \begin{itemize}
    \item \verb|Float32|~: IEEE 754 32-bit floating point numbers.
    \item \verb|Float64|~: IEEE 754 64-bit floating point numbers.
  \end{itemize}
\end{itemize}

\subsection{Integer Literals}

The default type for an integer literal is \verb|Int32|:
\begin{verbatim}
  julia> typeof(1)
  Int32
\end{verbatim}
Larger integer literals that cannot be represented in 32 bits but can be represented in 64 bits will create 64-bit integers:
\begin{verbatim}
  julia> typeof(4294967296)
  Int64
\end{verbatim}
Integers can be input in hexadecimal form using the \verb|0x| prefix as in C:
\begin{verbatim}
  julia> 0xff
  255

  julia> typeof(ans)
  Int32

  julia> 0xffffffff
  4294967295

  julia> typeof(ans)
  Int64
\end{verbatim}
There is no literal input format for integer types other than \verb|Int32| and \verb|Int64|. You can, however convert \verb|Int32| and \verb|Int64| values to other types easily:
\begin{verbatim}
  julia> int8(-15)
  -15

  julia> typeof(ans)
  Int8

  julia> uint8(231)
  231

  julia> typeof(ans)
  Uint8
\end{verbatim}

\subsection{Floating Point Literals}

Floating point numbers are input in the standard formats:
\begin{verbatim}
  julia> 1.0
  1.0

  julia> 1.
  1.0

  julia> 0.5
  0.5

  julia> .5
  0.5

  julia> -1.23
  -1.23

  julia> 1e10
  1e+10

  julia> 2.5e-4
  0.00025
\end{verbatim}
The above results are all \verb|Float64| values. There is no literal format for \verb|Float32|, but you can convert values to \verb|Float32| easily:
\begin{verbatim}
  julia> float32(-1.5)
  -1.5

  julia> typeof(ans)
  Float32
\end{verbatim}
There are three specified floating point values that do not correspond to a point on the real number line: plus and minus infinity, and not-a-number (NaN).
Here are their literal input forms:
\begin{verbatim}
  julia> Inf
  Inf

  julia> -Inf
  -Inf

  julia> NaN
  NaN
\end{verbatim}
As specified by the IEEE 754 standard, these floating point values are the results of certain arithmetic operations:
\begin{verbatim}
  julia> 1/0
  Inf

  julia> -5/0
  -Inf

  julia> 0.000001/0
  Inf

  julia> 0/0
  NaN

  julia> 500 + Inf
  Inf

  julia> 500 - Inf
  -Inf

  julia> Inf - Inf
  NaN

  julia> Inf/Inf
  NaN
\end{verbatim}

\subsection{Arithmetic and Bitwise Operations}

The following arithmetic and bitwise operations are supported on built-in arithmetic types:
\begin{itemize}
  \item arithmetic operations (integer and floating point):
  \begin{itemize}
    \item \verb|+x|~: unary plus is the identity operation.
    \item \verb|-x|~: unary minus maps values to their additive inverses.
    \item \verb|x + y|~: plus performs addition.
    \item \verb|x - y|~: binary minus performs subtraction.
    \item \verb|x * y|~: times performs multiplication.
    \item \verb|x / y|~: divide performs division.
  \end{itemize}
  \item bitwise operations (integer only)\,:
  \begin{itemize}
    \item \verb|~x|~: bitwise not.
    \item \verb|x & y|~: bitwise and.
    \item \texttt{x | y}~: bitwise or.
    \item \verb|x $ y|~: bitwise xor.
  \end{itemize}
\end{itemize}
Here are some simple examples:
\begin{verbatim}
  julia> 1+2+3
  6

  julia> 1-2
  -1

  julia> 3*2/12
  0.5
\end{verbatim}
Julia has a powerful and flexible type promotion system that allows arithmetic operations on mixtures of argument types to work naturally:
\begin{verbatim}
  julia> 1+2.5
  3.5

  julia> 0.5*12
  6.0

  julia> 3*2/12+1
  1.5
\end{verbatim}
The above operations all promote to \verb|Float64|s since that is the smallest floating point type that can faithfully represent all \verb|Int32| values.
However, more nuanced promotions also work:
\begin{verbatim}
  julia> uint8(12) - int8(15)
  -3

  julia> typeof(ans)
  Int16

  julia> uint8(12) - float32(1.5)
  10.5

  julia> typeof(ans)
  Float32
\end{verbatim}
Here are some examples with bitwise operations:
\begin{verbatim}
  julia> ~123
  -124

  julia> ~uint32(123)
  4294967172

  julia> ~uint8(123)
  132

  julia> 123 & 234
  106

  julia> 123 | 234
  251

  julia> typeof(ans)
  Int32

  julia> uint8(123) | uint16(234)
  251

  julia> typeof(ans)
  Uint16

  julia> 123 $ 234
  145
\end{verbatim}
As a general rule of thumb, arguments are promoted to the smallest type that can accurately represent all of the arguments. See \Section{conversion-and-promotion} for further details.

\subsection{Numeric Comparisons}

Standard comparison operations are defined for primitive numeric types:
\begin{itemize}
  \item \verb|==|~: equality.
  \item \verb|!=|~: inequality.
  \item \verb|<|~: less than.
  \item \verb|<=|~: less than or equal to.
  \item \verb|>|~: greater than.
  \item \verb|>=|~: greater than or equal to.
\end{itemize}
Here are some simple examples:
\begin{verbatim}
  julia> 1 == 1
  true

  julia> 1 == 2
  false

  julia> 1 != 2
  true
  
  julia> 1 == 1.0
  true

  julia> 1 < 2
  true

  julia> 1.0 > 3
  false

  julia> 1 >= 1.0
  true

  julia> -1 <= 1
  true

  julia> -1 <= -1
  true

  julia> -1 <= -2
  false

  julia> 3 < -0.5
  false
\end{verbatim}
As can be seen here, promotion also applies to comparisons:
the comparisons are performed in whatever type the arguments are promoted to, which is generally the smallest type they can all be represented faithfully in.

After promotion to a common type, integers are compared in the standard manner:
by comparison of bits.
Floating point numbers are compared according to the IEEE 754 standard:
finite numbers are compared bitwise and given their usual ordering;
positive infinite values are equal to each other and greater than everything else besides \verb|NaN|;
negative infinite values are equal to each other and less then everything else besides \verb|NaN|;
all comparisons with \verb|NaN| values are false, including equality with itself:
\begin{verbatim}
  julia> NaN == NaN
  false
\end{verbatim}
For situations where one wants to compare floating point values in such a way that \verb|NaN == NaN|, e.g. hash key comparisons, the function \verb|isequal| is also provided, which considers \verb|NaN|s to be equal:
\begin{verbatim}
  julia> isequal(NaN,NaN)
  true
\end{verbatim}
Unlike most languages, comparisons can be arbitrarily chained:
\begin{verbatim}
  julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
  true
\end{verbatim}
Chaining comparisons is quite convenient in many numerical codes.

\subsection{Rational Numbers}

There is a special\footnote{Actually, it's not that special: the \texttt{//} operator exists \emph{a priori}, but its usage for constructing rational numbers is defined entirely in the language itself.} input syntax for rational numbers in Julia:
\begin{verbatim}
  julia> 2//3
  2//3

  julia> typeof(ans)
  Rational{Int32}
\end{verbatim}
The type of a rational number is a parametric type, a concept which is explained in detail later on in \Section{struct-constructors}.
For the moment, it suffices to explain that \verb|2//3| is a ratio of \verb|Int32| values.
If you construct a \verb|Rational| from values that are not in lowest terms, they will be normalized to lowest terms:
\begin{verbatim}
  julia> 6//9
  2//3

  julia> -4//8
  -1//2

  julia> 5//-15
  -1//3

  julia> -4//-12
  1//3
\end{verbatim}
All arithmetic operations are also defined on \verb|Rational|s:
\begin{verbatim}
  julia> 2//4 + 1//6
  2//3

  julia> 5//12 - 1//4
  1//6

  julia> 5//8 * 3//12
  5//32

  julia> (6//5) / (10//7)
  21//25
\end{verbatim} % TODO: fix example once precedence is fixed.
\verb|Rational|s can be easily converted to floating point numbers:
\begin{verbatim}
  julia> float(3//4)
  0.75
\end{verbatim}
All such conversions obey the following identity for all integral \verb|a| and \verb|b|:
\begin{verbatim}
  julia> isequal(float(a//b), a/b)
  true
\end{verbatim}
This includes cases where \verb|a == 0| or \verb|b == 0|, in which situations the conversion from rational to float produces the appropriate $\pm$\verb|Inf| or \verb|NaN| value:
\begin{verbatim}
  julia> 5//0
  1//0

  julia> float(5//0)
  Inf

  julia> isequal(float(5//0), 5/0)
  true

  julia> 0//0
  0//0

  julia> float(0//0)
  NaN

  julia> isequal(float(0//0), 0/0)
  true

  julia> -3//0
  -1//0

  julia> float(-3//0)
  -Inf

  julia> isequal(float(-3//0), -3/0)
  true
\end{verbatim}
In a sense, Julia \verb|Rational|s are a convenient way of deferring the computation of integer ratios, thereby avoiding the accumulation of floating point errors.

\section{Control Flow}



\section{Functions}

The basic syntax for defining functions in Julia is similar to Matlab:
\begin{verbatim}
  function f(x,y)
    x + y
  end
\end{verbatim}
In fact, this precise declaration of \verb|f| will work in both Julia and Matlab, defining a function named \verb|f| returning the sum of its two arguments.
There are, however, already some significant differences to note:
\begin{itemize}
\item In Matlab, this definition must be in its own file, named \verb|f.m|.
In Julia, this expression can appear anywhere, including at the repl prompt.
\item In Matlab, the closing \verb|end| is optional, being implied by the end of the file.
In Julia, the terminating \verb|end| is required.
\end{itemize}
In general, while the function definition is reminiscent of Matlab, the similarity is largely superficial.
Rather than continually comparing the two, in what follows, we will simply describe the behavior of functions in Julia.

There is a second, more compact syntax for defining a function in Julia.
The traditional function declaration syntax demonstrated above is equivalent to the following terse form:
\begin{verbatim}
  f(x,y) = x + y
\end{verbatim}
In this short form, the body of the function must be a single expression, although it can be a complex compound expression.
Short, simple function definitions are quite common in Julia.
The short function syntax is accordingly quite idiomatic, and considerably reduces both typing and visual noise.

\subsection{The \texttt{return} Keyword}

The returned value of a function is the value of the last expression evaluated, which is, by default, the last expression in the body of the function definition.
In the example function \verb|f|, this is simply the value of the expression \verb|x + y|.
As in C, and most other imperative or functional languages, the \verb|return| keyword can cause the function to return from any point, optionally providing an expression whose value is returned:
\begin{verbatim}
  function g(x,y)
    return x * y
    x + y
  end
\end{verbatim}
Since functions definitions can be entered directly into the repl, it is easy to try these definitions out to compare them:
\begin{verbatim}
  julia> function g(x,y)
           return x * y
           x + y
         end
  Methods for generic function g
  g(Any,Any)

  julia> g(2,3)
  6

  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(2,3)
  5
\end{verbatim}
Of course, in a purely linear function body like \verb|g|, the usage of \verb|return| is pointless since the expression \verb|x + y| is never evaluated and we could simply make \verb|x * y| the last expression in the function and omit the \verb|return|.
In conjunction with other control flow, however, \verb|return| is of real use.
Here, for example is a function which computes the hypotenuse length of a right triangle with sides of length $x$ and $y$, carefully avoiding numerical problems in corner cases:
\begin{verbatim}
  function hypot(x,y)
      x = abs(x)
      y = abs(y)
      if x > y
          r = y/x
          return x*sqrt(1+r*r)
      end
      if y == 0
          return zero(x)
      end
      r = x/y
      return y*sqrt(1+r*r)
  end
\end{verbatim}
There are three possible points of return from this function, returning the values of three different expressions, depending on the values of $x$ and $y$.
The return on the last line can be omitted since it is the last expression in the function.

\subsection{Specializing Functions for Given Types}
\subsection{Functional Equivalents of Operators}
\subsection{Anonymous Functions}
\subsection{Returning Multiple Values}
\subsection{Varargs Functions}
\section{Defining Types}
\subsection{Tag Types}
\subsection{Struct Types}

Julia comes with pre-defined rational and complex numeric types, but they are just defined in the language in terms of the more basic numeric types given above using the standard facility for defining new types. For example, the declaration of the \verb|Rational| type is the following:
\begin{verbatim}
  struct Rational{T<:Int} <: Real
    num::T
    den::T
  end
\end{verbatim}
A few facts are in order before you can understand this declaration:
\begin{itemize}
\item A \verb|struct| type is a named bundle of fields as in the C language. In this case the fields are \verb|num| and \verb|den| which are used to store the numerator and the denominator, respectively, of a rational number.
\item The \verb|Rational{T}| syntax is used for parametric types. This declaration defines \verb|Rational| with respect to a type parameter, \verb|T|.
\item The \verb|<:| operator asserts that the value on the left is a subtype of the value on the right. In this case it is used twice:
  \begin{itemize}
    \item to assert that the type parameter, \verb|T|, is a subtype of \verb|Int|, which includes all of the above integer types;
    \item to assert that \verb|Rational| itself is a subtype of \verb|Real|, which includes the integer and floating-point types as well.
  \end{itemize}
\item The \verb|::| operator asserts that the name on the left will always be bound to a value of the type on the right. Thus whatever the parameter \verb|T| is given as, the numerator and denominator of the rational number must be of that type.
\end{itemize}
This is all somewhat complicated, but the result is easy to use:
\begin{verbatim}
  julia> Rational(1,2)
  1//2

  julia> typeof(ans)
  Rational{Int32}
\end{verbatim}
Applying the \verb|Rational| type to a pair of values (1,2) creates a \verb|Rational| with those values bound to the num and den fields. The output notation 1//2 is also acceptable as input notation:
\begin{verbatim}
  julia> 1//2
  1//2
\end{verbatim}
In fact, it is preferred because \verb|Rational| directly constructs a Rational number, while the \verb|//| form puts it into lowest terms first:
\begin{verbatim}
  julia> Rational(2,4)
  2//4

  julia> 2//4
  1//2

  julia> Rational(2,-3)
  2//-3

  julia> 2//-3
  -2//3

  julia> Rational(-3,-9)
  -3//-9

  julia> -3//-9
  1//3
\end{verbatim}
The \verb|Rational| form is retained to give you the ability to construct \verb|Rational|s with arbitrary numerators and denominators should you care to do so. Operations on \verb|Rational|s are smart enough to handle this gracefully:
\begin{verbatim}
  julia> Rational(2,4) == Rational(1,2)
  true
\end{verbatim}
Despite being effectively user-defined types, \verb|Rational| values interoperate completely transparently with other numeric types:
\begin{verbatim}
  julia> 1//2 + 2
  5//2

  julia> 1//2 + 1.5
  2.0
\end{verbatim}
If you want to create an ``exotic'' rational object of a type like \verb|Rational{Uint8}| all you need to do is use \verb|Uint8| values to construct them:
\begin{verbatim}
  julia> uint8(123)//uint8(234)
  41//78

  julia> typeof(ans)
  Rational{Uint8}
\end{verbatim}
If you use mixed types to construct a \verb|Rational|, the same promotions that are used for arithmetic apply:
\begin{verbatim}
  julia> uint8(123)//int8(-12)
  -41//4

  julia> typeof(ans)
  Rational{Int16}
\end{verbatim}

\subsection{Struct Constructors}
\sec{struct-constructors}

\subsection{Bits Types}

\subsection{Conversion and Promotion}
\sec{conversion-and-promotion}

\subsection{Other Kinds of Types}
\section{Tensors and Comprehensions}
\section{Strings}
\section{I/O}
\section{Data Structures}
\subsection{Hash Tables}
\subsection{Sets}
\subsection{Queues and Dequeues}
\subsection{Trees}
\subsection{Lists}
\section{Parallel Computing}
\section{C Interface}
\section{Shell Interface}
\section{Macros}
\section{Julia Command-Line Options}

\end{document}
