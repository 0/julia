\documentclass{article}

\newcommand{\thetitle}{The Julia Programming Language}

\usepackage{amsmath}
\usepackage[hyperfigures,bookmarks,bookmarksopen,bookmarksnumbered,colorlinks,linkcolor=black,citecolor=black,filecolor=blue,menucolor=black,pagecolor=blue,frenchlinks=true,pdftitle={\thetitle}]{hyperref}
\usepackage[left=1in,top=1in,right=1in,bottom=1.25in,nohead]{geometry}
\usepackage[utf8x]{inputenc}

\title{\thetitle}
\author{
Jeff Bezanson \vspace{0.5em}\\
Stefan Karpinski \vspace{0.5em}\\
Viral Shah \vspace{0.5em}
}

\renewcommand{\sec}[1]{\label{sec:#1}}
\newcommand{\fig}[1]{\label{fig:#1}}
\newcommand{\tab}[1]{\label{tab:#1}}

\newcommand{\Section}[1]{\hyperref[sec:#1]{Section~\ref*{sec:#1}}}
\newcommand{\Figure}[1]{\hyperref[fig:#1]{Figure~\ref*{fig:#1}}}
\newcommand{\Table}[1]{\hyperref[tab:#1]{Table~\ref*{tab:#1}}}

\renewcommand{\bullet}{{$\diamond$}}
\renewcommand{\labelitemi}{\bullet}
\renewcommand{\labelitemii}{\bullet}
\renewcommand{\labelitemiii}{\bullet}

\renewcommand{\O}{\ensuremath{\operatorname{O}}}

\begin{document}

\maketitle

Scientific computing has traditionally required the highest performance, yet domain experts have largely moved to slower dynamic languages for daily work.
We believe there are many good reasons to prefer dynamic languages for these applications, and we do not expect their use to diminish.
Fortunately, modern language design and compiler techniques make it possible to mostly eliminate the performance trade-off and provide a single environment productive enough for prototyping and performant enough for deploying applications.
The Julia programming language fills this role:
it is a flexible and dynamic language, designed expressly for scientific computing, and achieving performance comparable to traditional compiled languages.

The syntax of Julia is similar to that of Matlab, and consequently Matlab programmers should feel immediately comfortable with Julia.
While Matlab is quite effective for prototyping and exploring numerical linear algebra, it has limitations for programming tasks outside of this relatively narrow scope.
Julia keeps Matlab's ease and expressiveness for high-level numerical computing, but transcends its general programming limitations.
To that end, it borrows much from the C programming language, and is also strongly influenced by the lineage of dynamic languages:
Lisp, Perl, Python and Ruby.

\section{Getting Started}
\sec{getting-started}

\subsection{How to Obtain and Install Julia}
\sec{obtaining-and-installing}

\subsection{Running Code}
\sec{running-code}

Here's how you start and interact with the Julia read-eval-print loop (repl):

\begin{verbatim}
  $ julia
                 _      
     _       _ _(_)_     |
    (_)     | (_) (_)    |  
     _ _   _| |_  __ _   |
    | | | | | | |/ _` |  |
    | | |_| | | | (_| |  |  2009-2010 contributors
   _/ |\__'_|_|_|\__'_|  |  
  |__/                   |

  julia> 1 + 2
  3

  julia> load("file.j");
\end{verbatim}
The \verb|load| function reads and evaluates the contents of the given file.
The semicolon at the end of a repl line suppresses output of the expression value.
To run code in a file non-interactively, you can give it as the first argument to the julia command:
\begin{verbatim}
  $ julia script.j arg1 arg2...
\end{verbatim}
As the example implies, the following command-line arguments to julia are taken as command-line arguments to the program \verb|script.j|.
There are a variety of other ways to run Julia code and provide options to the \verb|julia| program, similar to the \verb|perl| and \verb|ruby| programs.
See \Section{command-line-options} for details.

\section{Numbers and Arithmetic}
Julia supports a broad range of numeric types together with the full complement of arithmetic and bitwise operations.
The following are Julia's built-in primitive numeric types:

\begin{itemize}
  \item Integer types:
  \begin{itemize}
    \item \verb|Int8|~: signed 8-bit integers ranging from $-2^7$ to $2^7-1$.
    \item \verb|Uint8|~: unsigned 8-bit integers ranging from 0 to $2^8-1$.
    \item \verb|Int16|~: signed 16-bit integers ranging from $-2^{15}$ to $2^{15}-1$.
    \item \verb|Uint16|~: unsigned 16-bit integers ranging from 0 to $2^{16}-1$.
    \item \verb|Int32|~: signed 32-bit integers ranging from $-2^{31}$ to $2^{31}-1$.
    \item \verb|Uint32|~: unsigned 32-bit integers ranging from 0 to $2^{32}-1$.
    \item \verb|Int64|~: signed 64-bit integers ranging from $-2^{63}$ to $2^{63}-1$.
    \item \verb|Uint64|~: unsigned 64-bit integers ranging from 0 to $2^{64}-1$.
  \end{itemize}
  \item Floating point types:
  \begin{itemize}
    \item \verb|Float32|~: IEEE 754 32-bit floating point numbers.
    \item \verb|Float64|~: IEEE 754 64-bit floating point numbers.
  \end{itemize}
\end{itemize}

\subsection{Integer Literals}

The default type for an integer literal is \verb|Int32|:
\begin{verbatim}
  julia> typeof(1)
  Int32
\end{verbatim}
Larger integer literals that cannot be represented in 32 bits but that can be represented in 64 bits will create 64-bit integers:
\begin{verbatim}
  julia> typeof(4294967296)
  Int64
\end{verbatim}
Integers can be input in hexadecimal form using the \verb|0x| prefix as in C:
\begin{verbatim}
  julia> 0xff
  255

  julia> typeof(ans)
  Int32

  julia> 0xffffffff
  4294967295

  julia> typeof(ans)
  Int64
\end{verbatim}
There is no literal input format for integer types besides \verb|Int32| and \verb|Int64|. You can, however convert \verb|Int32| and \verb|Int64| values to other types easily:
\begin{verbatim}
  julia> int8(-15)
  -15

  julia> typeof(ans)
  Int8

  julia> uint8(231)
  231

  julia> typeof(ans)
  Uint8
\end{verbatim}

\subsection{Floating Point Literals}

Floating point numbers are input in the standard formats:
\begin{verbatim}
  julia> 1.0
  1.0

  julia> 1.
  1.0

  julia> 0.5
  0.5

  julia> .5
  0.5

  julia> -1.23
  -1.23

  julia> 1e10
  1e+10

  julia> 2.5e-4
  0.00025
\end{verbatim}
The above results are all \verb|Float64| values. There is no literal format for \verb|Float32|, but you can convert values to \verb|Float32| easily:
\begin{verbatim}
  julia> float32(-1.5)
  -1.5

  julia> typeof(ans)
  Float32
\end{verbatim}
There are three specified standard floating point values that do not correspond to a point on the real number line: infinity (\verb|Inf|), minus infinity (\verb|-Inf|), and not-a-number (\verb|NaN|).
Here are their literal input forms:
\begin{verbatim}
  julia> Inf
  Inf

  julia> -Inf
  -Inf

  julia> NaN
  NaN
\end{verbatim}
By the IEEE 754 standard, these floating point values are the results of certain arithmetic operations:
\begin{verbatim}
  julia> 1/0
  Inf

  julia> -5/0
  -Inf

  julia> 0.000001/0
  Inf

  julia> 0/0
  NaN

  julia> 500 + Inf
  Inf

  julia> 500 - Inf
  -Inf

  julia> Inf - Inf
  NaN

  julia> Inf/Inf
  NaN
\end{verbatim}

\subsection{Arithmetic and Bitwise Operations}

The following arithmetic and bitwise operations are supported on built-in arithmetic types:
\begin{itemize}
  \item arithmetic operations (integer and floating point):
  \begin{itemize}
    \item \verb|+x|~: unary plus is the identity operation.
    \item \verb|-x|~: unary minus maps values to their additive inverses.
    \item \verb|x + y|~: plus performs addition.
    \item \verb|x - y|~: binary minus performs subtraction.
    \item \verb|x * y|~: times performs multiplication.
    \item \verb|x / y|~: divide performs division.
  \end{itemize}
  \item bitwise operations (integer only)\,:
  \begin{itemize}
    \item \verb|~x|~: bitwise not.
    \item \verb|x & y|~: bitwise and.
    \item \texttt{x | y}~: bitwise or.
    \item \verb|x $ y|~: bitwise xor.
    \item \verb|x << y|~: logical shift left.
    \item \verb|x >> y|~: logical shift right.
    \item \verb|x >>> y|~: arithmetic shift right.
  \end{itemize}
\end{itemize}
Here are some simple examples:\,\footnote{By convention, we tend to space less tightly binding operations less tightly, but there are no syntactic constraints.}
\begin{verbatim}
  julia> 1 + 2 + 3
  6

  julia> 1 - 2
  -1

  julia> 3*2/12
  0.5
\end{verbatim}
Julia has a powerful and flexible type promotion system that allows arithmetic operations on mixtures of argument types to work naturally:
\begin{verbatim}
  julia> 1 + 2.5
  3.5

  julia> 0.5*12
  6.0

  julia> 3*2/12 + 1
  1.5
\end{verbatim}
The above operations all promote to \verb|Float64| since that is the smallest floating point type that can faithfully represent all possible \verb|Int32| values.
However, more nuanced promotions also work:
\begin{verbatim}
  julia> uint8(12) - int8(15)
  -3

  julia> typeof(ans)
  Int16

  julia> uint8(12) - float32(1.5)
  10.5

  julia> typeof(ans)
  Float32
\end{verbatim}
Here are some examples with bitwise operations:
\begin{verbatim}
  julia> ~123
  -124

  julia> ~uint32(123)
  4294967172

  julia> ~uint8(123)
  132

  julia> 123 & 234
  106

  julia> 123 | 234
  251

  julia> typeof(ans)
  Int32

  julia> uint8(123) | uint16(234)
  251

  julia> typeof(ans)
  Uint16

  julia> 123 $ 234
  145
\end{verbatim}
As a general rule of thumb, arguments are promoted to the smallest type that can accurately represent all of the arguments. See \Section{conversion-and-promotion} for further details.

\subsection{Numeric Literal Coefficients}

To make common numeric formulas and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication.
This makes writing polynomial expressions much cleaner:
\begin{verbatim}
  julia> x = 3
  3

  julia> 2x + 1
  7

  julia> 2x^2 - 3x + 1
  10

  julia> 1.5x^2 - .5x + 1
  13.0
\end{verbatim}
Juxtaposed numeric coefficients conflict with two numeric literal syntaxes:
hexadecimal integer literals and engineering notation for floating point literals:
\begin{itemize}
\item For example, the hexadecimal integer literal expression \verb|0xff| could also be interpreted as the numeric literal \verb|0| multiplied by the variable \verb|xff|.
\item Likewise, the floating point literal expression \verb|1e10| could be interpreted as the numeric literal \verb|1| multiplied by the variable \verb|e10|, and similarly with the equivalent \verb|E| form.
\end{itemize}
In both cases, we resolve the ambiguity in favor of the numeric literals:
\begin{itemize}
\item Expressions starting with \verb|0x| are always hexadecimal literals.
\item Expressions starting with $d.dd$\,\verb|e| or $d.dd$\,\verb|E| are always floating point literals.
\end{itemize}

\subsection{Numeric Comparisons}\sec{numeric-comparisons}

Standard comparison operations are defined for primitive numeric types:
\begin{itemize}
  \item \verb|==|~: equality.
  \item \verb|!=|~: inequality.
  \item \verb|<|~: less than.
  \item \verb|<=|~: less than or equal to.
  \item \verb|>|~: greater than.
  \item \verb|>=|~: greater than or equal to.
\end{itemize}
Here are some simple examples:
\begin{verbatim}
  julia> 1 == 1
  true

  julia> 1 == 2
  false

  julia> 1 != 2
  true
  
  julia> 1 == 1.0
  true

  julia> 1 < 2
  true

  julia> 1.0 > 3
  false

  julia> 1 >= 1.0
  true

  julia> -1 <= 1
  true

  julia> -1 <= -1
  true

  julia> -1 <= -2
  false

  julia> 3 < -0.5
  false
\end{verbatim}
As is evident here, promotion also applies to comparisons:
the comparisons are performed in whatever type the arguments are promoted to, which is generally the smallest type in which all the values can be faithfully represented.

After promotion to a common type, integers are compared in the standard manner:
by comparison of bits.
Floating point numbers are compared according to the IEEE 754 standard:
finite numbers are compared bitwise and given their usual ordering;
positive infinite values are equal to each other and greater than everything else besides \verb|NaN|;
negative infinite values are equal to each other and less then everything else besides \verb|NaN|;
\verb|NaN| is not equal to, less than, or greater than anything, including itself:
\begin{verbatim}
  julia> NaN == NaN
  false

  julia> NaN != NaN
  true

  julia> NaN < NaN
  false

  julia> NaN > NaN
  false
\end{verbatim}
For situations where one wants to compare floating point values in such a way that \verb|NaN == NaN|, e.g. hash key comparisons, the function \verb|isequal| is also provided, which considers \verb|NaN|s to be equal:
\begin{verbatim}
  julia> isequal(NaN,NaN)
  true
\end{verbatim}
Unlike most languages, comparisons can be arbitrarily chained:
\begin{verbatim}
  julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
  true
\end{verbatim}
Chaining comparisons is quite convenient in many numerical codes.

\subsection{Rational Numbers}

Rational numbers can be constructed using the \texttt{//} operator:
\begin{verbatim}
  julia> 2//3
  2//3

  julia> typeof(ans)
  Rational{Int32}
\end{verbatim}
The type of a rational number is a parametric type, a concept explained in detail later in \Section{struct-constructors}.
For the moment, it suffices to say that \verb|2//3| is a ratio of \verb|Int32| values.
If you construct a \verb|Rational| from values that are not in lowest terms, they will be normalized to lowest terms:
\begin{verbatim}
  julia> 6//9
  2//3

  julia> -4//8
  -1//2

  julia> 5//-15
  -1//3

  julia> -4//-12
  1//3
\end{verbatim}
All arithmetic operations are also defined on \verb|Rational|s:
\begin{verbatim}
  julia> 2//4 + 1//6
  2//3

  julia> 5//12 - 1//4
  1//6

  julia> 5//8 * 3//12
  5//32

  julia> 6//5 / 10//7
  21//25
\end{verbatim}
\verb|Rational|s can be easily converted to floating point numbers:
\begin{verbatim}
  julia> float(3//4)
  0.75
\end{verbatim}
All such conversions obey the following identity for all integral \verb|a| and \verb|b|:
\begin{verbatim}
  julia> isequal(float(a//b), a/b)
  true
\end{verbatim}
This includes cases where \verb|a == 0| or \verb|b == 0|, in which situations the conversion from rational to float produces the appropriate $\pm$\verb|Inf| or \verb|NaN| value:
\begin{verbatim}
  julia> 5//0
  1//0

  julia> float(ans)
  Inf

  julia> 0//0
  0//0

  julia> float(ans)
  NaN

  julia> -3//0
  -1//0

  julia> float(ans)
  -Inf
\end{verbatim}
In a sense, Julia \verb|Rational|s are just a convenient way of deferring the computation of integer ratios, thereby avoiding the accumulation of floating point errors in intermediate calculations.

\subsection{Complex Numbers}

\section{Control Flow}

Julia provides a variety of control flow constructs:
\begin{itemize}
\item Compound expressions: \verb|begin| and \verb|(;)|.
\item Conditional evaluation: \verb|if|-\verb|esleif|-\verb|else| and \verb|?:| (ternary operator).
\item Short-circuit evaluation: \verb|&&|, \texttt{||} and chained comparisons.
\item Repeated evaluation: \verb|while| and \verb|for|.
\item Catch and throw: \verb|try|-\verb|catch| and \verb|throw|.
\item Symmetric coroutines: \verb|yieldto|.
\end{itemize}
The first five control flow mechanisms are standard to high-level programming languages.
Symmetric coroutines are not so standard:
they provide non-local control flow, similar to continuations.
In fact, both exception handling and cooperative multitasking are implemented in Julia using coroutines.
Everyday programming, however, requires no direct usage of coroutines.

\subsection{Compound Expressions}

Sometimes it is convenient to have a single expression which evaluates several subexpressions.
There are two Julia constructs that accomplish this:
\verb|begin| blocks and \verb|(;)| chains.
The value of both compound expression constructs is that of the last subexpression.
Here's an example of a \verb|begin| block:
\begin{verbatim}
  julia> z = begin
           x = 1
           y = 2
           x + y
         end
  3
\end{verbatim}
Since these are fairly small, simple expressions, they could easily be placed onto a single line, which is where the \verb|(;)| chain syntax comes in handy:
\begin{verbatim}
  julia> z = (x = 1; y = 2; x + y)
  3
\end{verbatim}
This syntax is particularly useful with the terse single-line function definition form introduced in \Section{functions}.
Although it is typical, there is no requirement that \verb|begin| be multiline or that \verb|(;)| be single-line:
\begin{verbatim}
  julia> begin x = 1; y = 2; x + y end
  3

  julia> (x = 1;
          y = 2;
          x + y)
  3
\end{verbatim}

\subsection{Conditional Evaluation}

Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of another expression.
Here is the anatomy of the \verb|if|-\verb|esleif|-\verb|else| conditional syntax:
\begin{verbatim}
  if x < y
    println("x is less than y")
  elseif x > y
    println("x is greater than y")
  else
    println("x is equal to y")
  end
\end{verbatim}
The semantics are just what you'd expect:
if the condition expression \verb|x < y| is \verb|true|, then the corresponding block is evaluated;
otherwise the condition expression \verb|x > y| is evaluated, and if it is \verb|true|, the corresponding block is evaluated;
if neither expression is true, the \verb|else| block is evaluated.
Here it is in action:
\begin{verbatim}
  julia> x = 1; y = 2;

  julia> if x < y
           println("x is less than y")
         elseif x > y
           println("x is greater than y")
         else
           println("x is equal to y")
         end
  x is less than y

  julia> x = 2; y = 1;

  julia> if x < y
           println("x is less than y")
         elseif x > y
           println("x is greater than y")
         else
           println("x is equal to y")
         end
  x is greater than y

  julia> x = 1; y = 1;

  julia> if x < y
           println("x is less than y")
         elseif x > y
           println("x is greater than y")
         else
           println("x is equal to y")
         end
  x is equal to y
\end{verbatim}
The \verb|elseif| and \verb|else| blocks are optional, and as many \verb|elseif| blocks as desired can be used.
The condition expressions in the \verb|if|-\verb|elseif|-\verb|else| construct are evaluated until the first one evaluates to \verb|true|, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.

Unlike C, Matlab, Perl, Python, and Ruby\,---\,but like Java, and a few other stricter, typed languages\,---\,it is an error if the value of a conditional expression is not \verb|true| or \verb|false|:
\begin{verbatim}
  julia> if 1
           println("true")
         end
  type error: lambda: in if, expected Bool, got Int32
\end{verbatim}
This error indicates that the conditional was of the wrong type:
\verb|Int32| rather than the required \verb|Bool|.

The so-called ``ternary operator,'' \verb|?:|, is closely related to the \verb|if|-\verb|elseif|-\verb|else| syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code.
It gets its name from being the only operator in most languages taking three operands:
\begin{quote}
  \emph{a} \verb|?| \emph{b} \verb|:| \emph{c}
\end{quote}
The expression \emph{a}, before the \verb|?|, is a condition expression, and the ternary operation evaluates the expression \emph{b}, before the \verb|:|, if the condition \emph{a} is \verb|true| or the expression \emph{c}, after the \verb|:|, if it is \verb|false|.

The easiest way to understand this behavior is to see an example.
In the previous example, the \verb|println| call is shared by all three branches:
the only real choice is which literal string to print.
This could be written more concisely using the ternary operator.
For the sake of clarity, let's try a two-way version first:
\begin{verbatim}
  julia> x = 1; y = 2;

  julia> println(x < y ? "less than" : "not less than")
  less than

  julia> x = 1; y = 0;

  julia> println(x < y ? "less than" : "not less than")
  not less than
\end{verbatim}
If the expression \verb|x < y| is true, the entire ternary operator expression evaluates to the string \verb|"less than"| and otherwise it evaluates to the string \verb|"not less than"|.
The original three-way example requires chaining multiple instances of the ternary operator:
\begin{verbatim}
  julia> println(x < y ? "x is less than y"    :
                 x > y ? "x is greater than y" : "x is equal to y")
  x is less than y

  julia> x = 2; y = 1;

  julia> println(x < y ? "x is less than y"    :
                 x > y ? "x is greater than y" : "x is equal to y")
  x is greater than y

  julia> x = 1; y = 1;

  julia> println(x < y ? "x is less than y"    :
                 x > y ? "x is greater than y" : "x is equal to y")
  x is equal to y
\end{verbatim}
To facilitate chaining, the operator associates from right to left.

It is significant that like \verb|if|-\verb|elseif|-\verb|else|, the expressions before and after the \verb|:| are only evaluated if the condition expression evaluates to \verb|true| or \verb|false|, respectively:
\begin{verbatim}
  v(x) = (println(x); x)

  julia> 1 < 2 ? v("yes") : v("no")
  yes
  "yes"

  julia> 1 > 2 ? v("yes") : v("no")
  no
  "no"
\end{verbatim}

\subsection{Short-Circuit Evaluation}

Short-circuit evaluation is quite similar to conditional evaluation.
The behavior is found in most imperative programming languages having the \verb|&&| and \texttt{||} boolean operators:
in a series of boolean expressions connected by these operators, only the minimum number of expressions are evaluated as are necessary to determine the final boolean value of the entire chain.
Explicitly, this means that:
\begin{itemize}
  \item In the expression \emph{a} \verb|&&| \emph{b}, the subexpression \emph{b} is only evaluated if \emph{a} evaluates to \verb|false|.
  \item In the expression \emph{a} \texttt{||} \emph{b}, the subexpression \emph{b} is only evaluated if \emph{a} evaluates to \verb|true|.
\end{itemize}
The reasoning is that \emph{a} \verb|&&| \emph{b} must be \verb|false| if \emph{a} is \verb|false|, regardless of the value of \emph{b}, and likewise, the value of \emph{a} \texttt{||} \emph{b} must be true if \emph{a} is \verb|true|, regardless of the value of \emph{b}.
Both \verb|&&| and \texttt{||} associate to the right, but \verb|&&| has higher precedence than than \texttt{||} does.
It's easy to experiment with this behavior:
\begin{verbatim}
  t(x) = (println(x); true)
  f(x) = (println(x); false)

  julia> t(1) && t(2)
  1
  2
  true

  julia> f(1) && t(2)
  1
  false

  julia> f(1) && f(2)
  1
  false

  julia> t(1) && t(2) && t(3)
  1
  2
  3
  true

  julia> t(1) && t(2) || t(3)
  1
  2
  true

  julia> f(1) && t(2) || t(3)
  1
  3
  true

  julia> t(1) && f(2) || t(3)
  1
  2
  3
  true

  julia> t(1) || f(2) && t(3)
  1
  true

  julia> f(1) || f(2) && t(3)
  1
  2
\end{verbatim}
Like condition expressions provided \verb|if|, \verb|elsif| or ternary operator, the values given to \verb|&&| or \texttt{||} must be boolean values (\verb|true| or \verb|false|).
Using a non-boolean value is an error:
\begin{verbatim}
  julia> 1 && 2
  type error: lambda: in if, expected Bool, got Int32
\end{verbatim}
Recall from \Section{numeric-comparisons} that numeric comparisons in Julia can be chained:
\begin{verbatim}
  julia> a = 1; b = 2; c = 3;

  julia> a < b <= c
  true
\end{verbatim}
This last expression is equivalent to the less convenient expression:
\begin{verbatim}
  julia> a < b && b <= c
  true
\end{verbatim}
In particular, this implies that chained comparisons exhibit short-circuit behavior.
Let's see this in action:
\begin{verbatim}
  v(x) = (println(x); x)

  julia> v(1) < v(2) <= v(3)
  1
  2
  3
  true

  julia> v(1) > v(2) <= v(3)
  1
  2
  false
\end{verbatim} % TODO: THIS IS NOT THE ACTUAL OUTPUT
The first pair of expressions will always be evaluated, since the first comparison must always be evaluated and requires both values.
Subsequent expressions, however, need not be evaluated if a comparison earlier in the chain is \verb|false|.
Note that the middle expression is only evaluated once, rather than twice as it would be if the expression were written as \verb|v(1) < v(2) && v(2) <= v(3)|.

\subsection{Repeated Evaluation}

\subsection{Catch and Throw}

\subsection{Coroutines}

\section{Functions}\sec{functions}

The basic syntax for defining functions in Julia is:
\begin{verbatim}
  function f(x,y)
    x + y
  end
\end{verbatim}
This syntax is similar to Matlab, but there are some significant differences:
\begin{itemize}
\item In Matlab, this definition must be saved in a file, named \verb|f.m|.
In Julia, this expression can appear anywhere, including at the repl prompt.
\item In Matlab, the closing \verb|end| is optional, being implied by the end of the file.
In Julia, the terminating \verb|end| is required.
\item in Matlab, this function would print the value \verb|x + y| but would not return any value.
In Julia, the last expression evaluated is a function's return value.
\item Expression values are never printed automatically except in the repl.
Semicolons are only required to separate expressions on the same line.
\end{itemize}
In general, while the function definition syntax is reminiscent of Matlab, the similarity is largely superficial.
Therefore, rather than continually comparing the two, in what follows, we will simply describe the behavior of functions in Julia directly.

There is a second, more terse syntax for defining a function in Julia.
The traditional function declaration syntax demonstrated above is equivalent to the following compact ``assignment form'':
\begin{verbatim}
  f(x,y) = x + y
\end{verbatim}
In the assignment form, the body of the function must be a single expression, although it can be a complex compound expression.
Short, simple function definitions are common in Julia.
The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.

\subsection{The \texttt{return} Keyword}

The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition.
In the example function, \verb|f|, this is simply the value of the expression \verb|x + y|.
As in C, and most other imperative or functional languages, the \verb|return| keyword can cause the function to return from any point, optionally providing an expression whose value is returned:
\begin{verbatim}
  function g(x,y)
    return x * y
    x + y
  end
\end{verbatim}
Since functions definitions can be entered directly into the repl, it is easy to try these definitions out to compare them:
\begin{verbatim}
  julia> function g(x,y)
           return x * y
           x + y
         end
  Methods for generic function g
  g(Any,Any)

  julia> g(2,3)
  6

  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(2,3)
  5
\end{verbatim}
Of course, in a purely linear function body like \verb|g|, the usage of \verb|return| is pointless since the expression \verb|x + y| is never evaluated and we could simply make \verb|x * y| the last expression in the function and omit the \verb|return|.
In conjunction with other control flow, however, \verb|return| is of real use.
Here, for example, is a function that computes the hypotenuse length of a right triangle with sides of length $x$ and $y$, carefully avoiding overflow of intermediate results:
\begin{verbatim}
  function hypot(x,y)
      x = abs(x)
      y = abs(y)
      if x > y
          r = y/x
          return x*sqrt(1+r*r)
      end
      if y == 0
          return zero(x)
      end
      r = x/y
      return y*sqrt(1+r*r)
  end
\end{verbatim}
There are three possible points of return from this function, returning the values of three different expressions, depending on the values of $x$ and $y$.
The \verb|return| on the last line could be omitted since it is the last expression.

\subsection{Specializing Functions for Given Types}

Julia allows multiple dispatch based on the types of function arguments:
\begin{verbatim}
  f(x,y) = x + y
  f(x::Float64, y::Float64) = x * y
\end{verbatim}
The appropriate version will be called based on the types of the argument values:
\begin{verbatim}
  julia> f(2,3)
  5

  julia> f(2.0,3.0)
  6.0
\end{verbatim}
Dispatch is done on all argument types and the most specific method that applies is called:
\begin{verbatim}
  julia> f(2,3.0)
  5.0
\end{verbatim}
Here, the second method of \verb|f| cannot be applied since \verb|2| is not a \verb|Float64|.
In the first method, the argument types are unconstrained, so this serves as a catchall method, and is called here.

If you've been entering these definitions in the repl, you'll have noticed that it shows you all the methods defined for a given ``generic function'' when a new method is defined or if you ask the repl to show the function object:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y::Float64) = x * y
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)

  julia> f
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)
\end{verbatim}
The \verb|Any| type is the default when no type is specified:
all Julia objects match \verb|Any|.
In formal type system literature, \verb|Any| is commonly called Top.\footnote{Julia also has a Bottom type called \texttt{None} which no object matches.}

Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language.
Core operations typically have dozens of methods:
\begin{verbatim}
  julia> +
  Methods for generic function +
  +(Real,Range{T<:Real})
  +(Real,Range1{T<:Real})
  +(Union(Range{T<:Real},Range1{T<:Real}),Real)
  +(Union(Range{T<:Real},Range1{T<:Real}),
    Union(Range{T<:Real},Range1{T<:Real}))
  +()
  +(Number,)
  +(Any,Any,Any)
  +(Any,Any,Any,Any)
  +(Any,Any,Any,Any,Any)
  +(Any,Any,Any,Any...)
  +(Int8,Int8)
  +(Int16,Int16)
  +(Int32,Int32)
  +(Int64,Int64)
  +(Uint8,Uint8)
  +(Uint16,Uint16)
  +(Uint32,Uint32)
  +(Uint64,Uint64)
  +(Float32,Float32)
  +(Float64,Float64)
  +(Char,Char)
  +(Rational{T<:Int},Rational{T<:Int})
  +(Complex{T<:Real},Complex{T<:Real})
  +(T<:Number,T<:Number)
  +(Number,Number)
  +(Tensor{T<:Number,N},)
  +(Tensor{S,N},Tensor{T,N})
  +(Number,Tensor{T,N})
  +(Tensor{T,N},Number)
\end{verbatim}
Multiple dispatch together with the flexible parametric type system, give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient specialized code at run time.

\subsection{Method Ambiguities}

It is possible to define a set of function methods such that ambiguous cases exist where for some combinations of argument types there is no unique most specific method which applies:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y) = 2x + y
  Methods for generic function f
  f(Float64,Any)
  f(Any,Any)

  julia> f(x, y::Float64) = x + 2y
  Warning: new definition f(Any,Float64) is ambiguous with
  f(Float64,Any). Make sure f(Float64,Float64) is also defined.
  Methods for generic function f
  f(Float64,Any)
  f(Any,Float64)
  f(Any,Any)

  julia> f(2,3)
  5

  julia> f(2.0,3)
  7.0

  julia> f(2,3.0)
  8.0

  julia> f(2.0,3.0)
  7.0
\end{verbatim}
Here the arguments \verb|2.0| and \verb|3.0| could be handled by either the \verb|f(Float64,Any)| or the \verb|f(Any,Float64)| method, and neither is more specific than the other.
In such cases, Julia warns you about this ambiguity, but allows you to proceed, arbitrarily picking a method.
You should avoid method ambiguities by specifying an appropriate method for the intersection case:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y::Float64) = 2x + 2y
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)

  julia> f(x::Float64, y) = 2x + y
  Methods for generic function f
  f(Float64,Float64)
  f(Float64,Any)
  f(Any,Any)

  julia> f(x, y::Float64) = x + 2y
  Methods for generic function f
  f(Float64,Float64)
  f(Float64,Any)
  f(Any,Float64)
  f(Any,Any)

  julia> f(2,3)
  5

  julia> f(2.0,3)
  7.0

  julia> f(2,3.0)
  8.0

  julia> f(2.0,3.0)
  10.0
\end{verbatim}
To suppress Julia's warning, the disambiguating method must be defined first.

\subsection{Operators Are Functions}

In Julia, most operators are all just functions with support for special syntax.
However, they can be used as normal functions as well:
\begin{verbatim}
  julia> 1 + 2 + 3
  6

  julia> (+)(1,2,3)
  6
\end{verbatim}
The infix form is exactly equivalent to the function application form\,---\,in fact the former is parsed to produce precisely the function call internally.
To add a new method to the \verb|+| operator, you just define a new method using the name of the operator.
For example, addition method for \verb|Complex| values is defined as:
\begin{verbatim}
  (+)(z::Complex, w::Complex) = Complex(z.re + w.re, z.im + w.im)
\end{verbatim}
Otherwise operators are no different than any other function in Julia.
When using an operator as a function, to be safe you can always wrap it in parentheses like \verb|(+)| above, but that is only strictly necessary for those operators that can be used in unary form: \verb|+|, \verb|-|, \verb|~|, and \verb|!|.
For others, the parentheses can be omitted:
\begin{verbatim}
  julia> (*)(1,2,3)
  6

  julia> *(1,2,3)
  6

  julia> (+)(1,2,3)
  6

  julia> +(1,2,3)
  no method +((Int32,Int32,Int32),)
\end{verbatim}
Since \verb|+| can be used in unary form, this syntax is parsed as unary application of \verb|+| to the tuple value \verb|(1,2,3)|, rather than the application of the \verb|+| function to the values 1, 2, and 3.

\subsection{Anonymous Functions}

Functions in Julia are first-class objects:
they can be assigned to variables, called using the standard function call syntax via the variable they have been assigned to, be it local or global;
they can be passed as arguments, and returned as values.
They can also be created anonymously, without giving them a name:
\begin{verbatim}
  julia> x -> x^2 + 2x - 1
  #<closure>
\end{verbatim}
This creates an unnamed function taking one argument and returning the value of the polynomial $x^2 + 2x - 1$ at that value.
The primary use for anonymous functions is passing them to functions which take functions as arguments.
A classic example is the \verb|map| function, which applies a function to each value of an array and returns a new array containing the resulting values:
\begin{verbatim}
  julia> map(round, [1.2,3.5,1.7])
  [1.0,4.0,2.0]
\end{verbatim} % TOOD: make sure type inference gets the right return type.
This is fine if a named function effecting the transform one wants already exists to pass as the first argument to \verb|map|.
Often, however, a such a named function does not exist.
In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:
\begin{verbatim}
  julia> map(x -> x^2 + 2x - 1, [1,3,-1])
  [2,14,-2]
\end{verbatim}

\subsection{Returning Multiple Values}
\subsection{Varargs Functions}

\section{Variable Scoping}

The \emph{scope} of a variable is the region of code within which a variable
is visible.
Variable scoping helps avoid variable naming conflicts.
The concept is intuitive:
two functions can both have arguments called \verb|x| without the two \verb|x|'s referring to the same thing.
Similarly there are many other cases where different blocks of code can use the same name without referring to the same thing.
The rules for when the same variable name does or doesn't refer to the same thing are called scope rules;
this section spells them out in detail.

Certain constructs in the language introduce \emph{scope blocks}, which
are regions of code that are eligible to be the scope of some set of variables.
The scope of a variable cannot be an arbitrary set of
source lines, but will always line up with one of these blocks. These
constructs introducing such blocks are:
\begin{itemize}
\item function bodies (any syntax)
\item \verb|while| loops
\item \verb|for| loops
\item \verb|try| blocks
\item \verb|catch| blocks
\item \verb|let| blocks
\item \verb|type| blocks.
\end{itemize}
Certain constructs introduce new variables into the current innermost scope. When
a variable is introduced into a scope, it is also inherited by all inner
scopes unless one of those inner scopes explicitly overrides it. These
constructs which introduce new variables into the current scope are as follows:
\begin{itemize}
\item A declaration \verb|local x| introduces a new local variable.
\item A declaration \verb|global x| makes \verb|x| in the current scope
and inner scopes refer to the global variable of that name.
\item A function's arguments are introduced as new local variables into the
function's body scope.
\item An assignment \verb|x = y| introduces a new local variable \verb|x|
only if \verb|x| is neither declared global nor explicitly introduced as local
by any enclosing scope, \emph{before or after} the current line of code.
\end{itemize}
In the following example, there is only one \verb|x| assigned both inside
and outside a loop:
\begin{verbatim}
  function foo(n)
      x = 0
      for i = 1:n
          x = x + 1
      end
      x
  end
  
  julia> foo(10)
  10
\end{verbatim}
In the next example, the loop has a separate \verb|x| and the function
always returns zero:
\begin{verbatim}
  function foo(n)
      x = 0
      for i = 1:n
          local x
          x = i
      end
      x
  end

  julia> foo(10)
  0
\end{verbatim}
In this example, an \verb|x| exists only inside the loop, and
the function encounters an undefined variable error on its last line
(unless there is a global variable \verb|x|):
\begin{verbatim}
  function foo(n)
      for i = 1:n
          x = i
      end
      x
  end

  julia> foo(10)
  in foo: x not defined
\end{verbatim}
A variable that is not assigned to or otherwise introduced locally defaults to global,
so this function would return the value of the global \verb|x|
if there is such a variable, or produce an error if no such global exists.
As a consequence, the only way to assign to a global variable inside
a non-top-level scope is to explicitly declare the variable as global within some scope, since
otherwise the assignment would introduce a new local rather than assigning to the global. This rule works out
well in practice, since the vast majority of variables assigned inside
functions are intended to be local variables, and using global variables, should be the exception rather than the rule, especially assigning new values to them.

One last example shows that an outer assignment introducing \verb|x| need not come before an inner usage:
\begin{verbatim}
  function foo(n)
      f = y -> n + x + y
      x = 1
      f(2)
  end

  julia> foo(10)
  13
\end{verbatim}
This last example may seem slightly odd for a normal variable, but allows for named functions\,---\,which are just normal variables holding function objects\,---\,to be used before they are defined.
This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, both of which one typically sees in C programs.
In particular, mutual recursion is very simple to write.
Here's a rather inefficient way to test if positive integers are even or odd:\,\footnote{Julia provides built-in, efficient functions to test this called \texttt{iseven} and \texttt{isodd}.}
\begin{verbatim}
  even(n) = n == 0 ? true  :  odd(n-1)
  odd(n)  = n == 0 ? false : even(n-1)

  julia> even(3)
  false

  julia> odd(3)
  true
\end{verbatim}
Since functions can be used before they are defined as long as they are defined by the time they are actually called, no syntax for forward declarations is necessary, and definitions can be ordered arbitrarily.

At the interactive prompt, variable scope works the same way as anywhere
else. The prompt behaves as if there is scope block wrapped around everything
you type, except that this scope block is identified with the global scope.
This is especially apparent in the case of assignments:
\begin{verbatim}
  julia> for i=1:1; y = 10; end
  ()
  
  julia> y
  y not defined
  
  julia> y = 0
  0
  
  julia> for i=1:1; y = 10; end
  ()
  
  julia> y
  10
\end{verbatim}
In the first case \verb|y| only exists inside the loop.
In the second case, an outer y has been introduced and so is inherited
within the loop. Due to the special identification of the prompt's scope
block with the global scope, it is not necessary to declare
\verb|global y| inside the loop. However, outside the interactive prompt
this declaration would be necessary in order to modify a global variable.

\section{Defining Types}
\subsection{Tag Types}
\subsection{Struct Types}

Julia comes with pre-defined rational and complex numeric types, but they are just defined in the language in terms of the more basic numeric types given above using the standard facility for defining new types. For example, the declaration of the \verb|Rational| type is the following:
\begin{verbatim}
  struct Rational{T<:Int} <: Real
    num::T
    den::T
  end
\end{verbatim}
A few facts are in order before you can understand this declaration:
\begin{itemize}
\item A \verb|struct| type is a named bundle of fields as in the C language. In this case the fields are \verb|num| and \verb|den| which are used to store the numerator and the denominator, respectively, of a rational number.
\item The \verb|Rational{T}| syntax is used for parametric types. This declaration defines \verb|Rational| with respect to a type parameter, \verb|T|.
\item The \verb|<:| operator asserts that the value on the left is a subtype of the value on the right. In this case it is used twice:
  \begin{itemize}
    \item to assert that the type parameter, \verb|T|, is a subtype of \verb|Int|, which includes all of the above integer types;
    \item to assert that \verb|Rational| itself is a subtype of \verb|Real|, which includes the integer and floating-point types as well.
  \end{itemize}
\item The \verb|::| operator asserts that the name on the left will be bound to a value of the type on the right. Thus whatever type parameter \verb|T| is given as, the numerator and denominator of the rational number are of that type.
\end{itemize}
This is all somewhat complicated, but the result is easy to use:
\begin{verbatim}
  julia> Rational(1,2)
  1//2

  julia> typeof(ans)
  Rational{Int32}
\end{verbatim}
Applying the \verb|Rational| type to a pair of values (1,2) creates a \verb|Rational|. The output notation 1//2 is also acceptable as input notation:
\begin{verbatim}
  julia> 1//2
  1//2
\end{verbatim}
Despite being effectively user-defined types, \verb|Rational| values interoperate completely with other numeric types:
\begin{verbatim}
  julia> 1//2 + 2
  5//2

  julia> 1//2 + 1.5
  2.0
\end{verbatim}
If you want to create an ``exotic'' rational object of a type like \verb|Rational{Uint8}| all you need to do is use \verb|Uint8| values to construct them:
\begin{verbatim}
  julia> uint8(123)//uint8(234)
  41//78

  julia> typeof(ans)
  Rational{Uint8}
\end{verbatim}
If you use mixed types to construct a \verb|Rational|, the same promotions that are used for arithmetic apply:
\begin{verbatim}
  julia> uint8(123)//int8(-12)
  -41//4

  julia> typeof(ans)
  Rational{Int16}
\end{verbatim}

\subsection{Struct Constructors}
\sec{struct-constructors}

\subsection{Bits Types}

\subsection{Conversion and Promotion}
\sec{conversion-and-promotion}

\subsection{Other Kinds of Types}

\section{Tensors and Comprehensions}

Julia introduces a new programming construct called a multidimensional
array comprehension or just an array comprehension for short. Array
comprehensions are similar to the notion of list comprehensions in
other languages such as Python, Haskell and OCaml, but extend this
notion to manipulate and generate arrays of arbitrary dimension. Each
dummy variable used in the array comprehension corresponds to a
dimension of the output array; if the comprehension expression value
itself has non-zero dimension then the total dimension of the output
is the number of dummy variables plus the dimension of the value. If
we view n-d arrays as rank-n tensors, and thus see 1-d arrays as
vectors and 2-d arrays as matrices, many common vector, matrix and
tensor operations can be expressed concisely and clearly using array
comprehensions.

Array comprehensions are envisioned to be a key construct of the julia
language that will differentiate it from other languages. On one hand,
Matlab is pretty fast, and it is almost impossible to beat Matlab at
what it does. On the other hand, Matlab codes when rewritten in C
often run 10 times faster. What gives? The key idea behind array
comprehensions is to express almost all operations at a higher level,
close to their mathematical definitions. Optimizations can then be
applied to this high level to produce heavily optimized low-level
code, for multiple comprehensions and compounded comprehensions. This
scheme should allow the generation of optimized low-level code from a
high level specification that matches the structure of optimized C
code written by a good C programmer.

\subsection{Array Comprehension Notations}

The following sections give three increasingly succinct syntaxes for writing array comprehensions. Through the forms, we follow the basic example of how to express the row sum and column sums of a matrix. We first present the most general, verbose notation for array comprehensions together with its meaning, and then present two increasingly abbreviated but equivalent forms.

\subsubsection{Explicit range}
This is the most general form for writing array comprehensions. The general form is:
\begin{verbatim}
A = [ F(x,y,...) | x=rx, y=ry, ... ]
\end{verbatim}

The meaning of this form is that F(x,y,...) is evaluated with the
variables x, y, etc. taking on each value in their given list of
values. Values can be specified as any iterable object, but will
commonly be ranges like 1:n or 2:(n-1), or explicit arrays of values
like [1.2, 3.4, 5.7]. The result is a tensor object with dimensions
that are the concatenation of the dimensions of the dummy variable
ranges rx, ry, etc. and the dimension of the result of each F(x,y,...)
evaluations—which must all have identical shape. See below for details
on array comprehensions of non-scalar expression.

To clarify, let's consider the concrete example of computing row and
column sums of a matrix, A. For a single dummy variable, the array
comprehension notation with explicit variable ranges is similar to
list comprehensions in other languages:
\begin{verbatim}
row_sums = [ sum(A[i,:]) | i=1:size(A,1) ]
col_sums = [ sum(A[:,j]) | j=1:size(A,2) ]
\end{verbatim}

\subsection{Array Comprehensions of Non-Scalar Expressions}
If the computed expression of an array comprehension is not a scalar,
then all the values produced must be arrays of identical shape. The
dummy variable vectorization dimensions come before the expression
dimensions making the total dimension of the output array the number
of dummy variables plus the dimension of the inner expression. This
convention can be expressed by the following identity. If F is a
function mapping scalars to vectors, the following holds:
\begin{verbatim}
[ F(i) | i=ri ] == [ F(i)[j] | i=ri, j=rj ]
\end{verbatim}

\subsection{Examples}

\begin{itemize}
\item Diagonal of a matrix is computed as:
\begin{verbatim}
d = [ A[i,i] | i=1:min(dim(A)) ]
\end{verbatim}
\item Matrix product is computed as:
\begin{verbatim}
C = [ sum([ A[i,j].*B[j,k] | j ]) | i=1:size(A,1), k=1:size(B,2) ]
\end{verbatim}


\end{itemize}

\section{Strings}
\sec{strings}

% Traditionally, strings are conceptualized as sequences of characters, which mathematically is a function from indices to characters.
% When all characters are exactly one byte, this can be conveniently and efficiently represented with a plain old array of bytes.
% It's simple and efficient.
% End of story.
% 
% Unicode complicates things because common encodings like UTF-8 and UTF-16 are variable-width, meaning that characters require different numbers of bytes in their representation.
% In UTF-8, for example, all of the ASCII characters are one byte, encoded just as in ASCII.
% All other characters, however, take between two and four bytes to represent.
% This means that you can't efficiently look up the $k$th character of a string by doing array indexing anymore:
% the $k$th byte of the representation is no longer the $k$th character.
% Worse still, a byte might not be the beginning of a character at all, but right in the middle of a character (this is called a ``continuation byte'').
% 
% If you allow people direct access to the bytes of an encoded string, they can and will do all sorts of bad things that produce invalid Unicode and broken behaviors when Unicode input is received.
% To provide a string abstraction that makes strings behave like functions from indices to Unicode characters (i.e. code points), you have to chose one of the following:
% \begin{enumerate}
% 
% \item Have fast, natural random access to characters, but store strings so that every character is big enough to accommodate the entire Unicode character set.
% The natural choice of encoding for this is UTF-32, in which each code point (integer value representing a unique character) is simply represented by its 32-bit integer value.
% This also requires processing every string before accessing or manipulating it to convert it from its input encoding (usually UTF-8) to UTF-32.
% Transcoding introduces a lot of overhead, forcing every string to be transcoded, typically both on input and output, as well as inflating memory usage for all strings.
% 
% \item Sacrifice the ability to represent every Unicode character and use only the two-byte characters of a 16-bit encoding like UTF-16.
% With this you can represent virtually all modern languages, but you cannot write in ancient languages like Egyptian hieroglyphs, Linear B, or represent some unusual modern characters such as certain unified Han ideographs.
% This allows fast random access, and reduces the memory inflation compared to the UTF-32 approach, but still requires transcoding almost every string on input and output.
% 
% \item Keep strings in their input form, but make indexing into a string an $\O(k)$ operation which requires scanning the entire string from the beginning to find the $k$th character from there.
% This turns a lot of straightforward $\O(n)$ string processing algorithms into $\O(n^2)$ algorithms unless you completely avoid indexing into strings altogether.
% 
% \item Represent strings by a clever, relatively complex data structure that allows strings to remain encoded, but somehow makes indexing the $k$th character look like it's faster than $\O(k)$, when it is amortized over many operations.
% One possible way to do this is to remember the last few indices that were accessed and figure out new indices relative to them.
% 
% \item Do not allow indexing into strings. Instead, only provide interfaces, such as iterating characters, which are Unicode safe as well as being efficiently implementable without transcoding strings.
% 
% \item Ignore the whole issue and just equate strings with byte arrays and let Unicode bugger itself (a.k.a.~the C approach\footnote{To be fair, the C language long predates the Unicode standard.}).
% 
% \end{enumerate}
% Technically, option 5 doesn't actually keep the abstraction of strings as functions from indices to characters, so perhaps it doesn't belong here;
% and option 6 isn't a solution at all, but rather a matter of deciding that you just don't care.
% Option 2 is not really a solution, either, but a pragmatic compromise that gets you 90\% of the way (unless you happen to want to process hieroglyphs).
% Frankly, none of these options is good enough for something as fundamental and performance-critical as string processing.
% 
% \subsection{The Partial Function Approach}
% \sec{partial-function-strings}
% 
% Our approach is to change the abstraction of what a string is instead of choosing any of the above.
% Rather than conceptualizing a string as a function from indices to characters, we conceptualize a string as a \emph{partial function} from indices to characters.
% What does this mean?
% It means that when indexing into a string, for some indices no character value is returned:
% instead of returning a value, the language throws an exception.
% So in short \verb|str[k]| will throw an exception if $k$ doesn't correspond to a character.
% For UTF-8 strings that are plain ASCII this will never happen.
% For UTF-32 strings it will never happen.
% For UTF-16 strings including only the common two-byte characters it will never happen.
% For other instances of encoded strings, it could happen, however.
% 
% How does this modified abstraction help?
% It recognizes that bytes and characters are not one-to-one in many encodings, but still allows you store strings in their native encoding and retrieve characters efficiently by a byte index, rather than a character index.
% If you try to get or set a character at an index that isn't the start of a character, it's an exception---indicating that the partial function isn't defined there.
% The ``string''---as one normally thinks of it---is the sequence characters returned by the string as the indices range from one to the maximum index.
% The gotcha is that some indices don't return a character.
% 
% Code that na\"ively iterates through all indices will work and work with C-like performance, until it encounters strange input data, at which point it will throw a nice clean exception letting you know exactly what the problem is.
% You can probably just modify the code to catch the exception and move on to the next index.
% Alternately, you can rewrite the code to use a Unicode character iterator instead.
% Moreover, if you always consider string indices as opaque objects, and never do arithmetic with them (iterating through indices counts as arithmetic: \verb|k+=1|), then as long as you only index into a string with an index given to you by a string function, this kind of thing will never happen.
% 
% By changing the string abstraction, we can support arbitrary string encodings and other representations at C-like efficiency and with a nice, safe, clean programmatic interface.

There are a few noteworthy high-level features about Julia's approach to strings:
\begin{enumerate}
\item Like C, but unlike most dynamic languages, Julia has a first-class type representing a single character, called \verb|Char|.
A \verb|Char| is a special kind of 32-bit integer, whose numeric value represents a single Unicode code point.
\item Conceptually, a \verb|String| is a \emph{partial function} from indices to \verb|Char| values --- for some index values, no character values is returned, and instead an exception is thrown.
This for allows efficient indexing into strings by the byte index of an encoded representation rather than by character index, which cannot be implemented efficiently and simply for variable-width string encodings.
\item There are many different classes implementing the \verb|String| interface, not a single special one.
They all implement a common programming interface, however, and any string type can be used in any function expecting a \verb|String|.
The predefined string types are no more special than user-defined ones.
\item Strings are immutable: the value of a \verb|String| object cannot be changed.
To construct a different string value, you construct a new string object from parts of other string objects.
\end{enumerate}

\subsection{Characters}

Like C, but unlike Perl, Python, or Ruby, Julia has a type for individual characters: \verb|Char|.
A \verb|Char| is just a 32-bit integer with a special literal representation and some specific arithmetic behaviors.
Here is how \verb|Char| values are input and shown:
\begin{verbatim}
  julia> 'x'
  'x'

  julia> typeof(ans)
  Char
\end{verbatim}
You can convert a Char to its integer value (code point) easily:
\begin{verbatim}
  julia> int('x')
  120

  julia> typeof(ans)
  Int32
\end{verbatim}
You can convert an integer value back to a \verb|Char| just as easily:
\begin{verbatim}
  julia> char(120)
  'x'
\end{verbatim}
Not all integer values are valid Unicode code points, but for performance, the \verb|char| conversion does not check that every character value is a valid Unicode code point.
If you want to check code points for validity, use the \verb|safe_char| conversion instead:
\begin{verbatim}
  julia> char(0xd800)
  '???'

  julia> safe_char(0xd800)
  invalid Unicode code point: U+d800

  julia> char(0x110000)
  '\U00110000'

  julia> safe_char(0x110000)
  invalid Unicode code point: U+110000
\end{verbatim}
As of this writing, the valid Unicode code points are \verb|U+0000| through \verb|U+d7ff| and \verb|U+e000| through \verb|U+10ffff|.
They have not all yet been assigned intelligible meanings, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.

You can input any Unicode character in single quotes using \verb|\u| followed by up to four hexadecimal digits or \verb|\U| followed by up to eight hexadecimal digits (the longest valid value only requires six):
\begin{verbatim}
  julia> '\u0'
  '\0'

  julia> '\u78'
  'x'

  julia> '\u2200'
  '∀'

  julia> '\U10ffff'
  '\U0010ffff'
\end{verbatim}
Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the \verb|\u| or \verb|\U| forms.
In addition to these Unicode forms, all of C's escaped input forms are usable as well:
\begin{verbatim}
  julia> int('\0')
  0

  julia> int('\t')
  9

  julia> int('\n')
  10

  julia> int('\e')
  27

  julia> int('\x7f')
  127

  julia> int('\177')
  127

  julia> int('\xff')
  255
\end{verbatim}
Like any integers, you can do arithmetic and comparisons with \verb|Char| values:
\begin{verbatim}
  julia> 'x' - 'a'
  23

  julia> 'A' < 'a'
  true

  julia> 'A' <= 'a' <= 'Z'
  false

  julia> 'A' <= 'X' <= 'Z'
  true
\end{verbatim}
Arithmetic with \verb|Char| values always promotes them to \verb|Int32|.
To create a new \verb|Char| value, explicit conversion is required:
\begin{verbatim}
  julia> 'A' + 1
  66

  julia> char(ans)
  'B'
\end{verbatim}
Requiring explicit conversion allows a series of intermediate computations to be done efficiently, only checking that the final value is a valid Unicode code point.

\subsection{String Basics}

Here is a basic string literal:
\begin{verbatim}
  julia> str = "Hello, world.\n"
  "Hello, world.\n"
\end{verbatim}
If you want to extract a character from a string, you index into it:
\begin{verbatim}
  julia> str[1]
  'H'

  julia> str[6]
  ','

  julia> str[end]
  '\n'

  julia> str[end-1]
  '.'
\end{verbatim}
Like all indexing in Julia, string indexing is 1-based, not 0-based.
Using an index less than 1 or greater than \verb|end| raises an error:
\begin{verbatim}
  julia> str[0]
  in next: arrayref: index out of range

  julia> str[end+1]
  in next: arrayref: index out of range
\end{verbatim}
You can also extract a substring using range indexing:
\begin{verbatim}
  julia> str[4:9]
  "lo, wo"
\end{verbatim}
Note the distinction between \verb|str[k]| and \verb|str[k:k]|:
\begin{verbatim}
  julia> str[6]
  ','

  julia> typeof(ans)
  Char

  julia> str[6:6]
  ","

  julia> typeof(ans)
  SubString
\end{verbatim}
The former is a single character value of type \verb|Char|, while the latter is a string value of type \verb|SubString| (we'll get into the nitty-gritty details later), a \verb|String| instance containing only a single character.
In Julia these are very different things.

One of the most useful string operations is concatenation:
\begin{verbatim}
  julia> greet = "Hello"
  "Hello"

  julia> who = "world"
  "world"

  julia> strcat(greet, ", ", who, ".\n")
  "Hello, world.\n"
\end{verbatim}
As in Perl, you can interpolate values and expressions into strings using \verb|$|:
\begin{verbatim}
  julia> "$greet, $who.\n"
  "Hello, world.\n"
\end{verbatim}
This more readable and convenient, and completely equivalent to the above string concatenation---the system rewrites this apparent single string literal into a concatenation of string literals with values.
The shortest valid expression after an unescaped \verb|$| is used as the interpolated value.
Thus, you can interpolate the value of any expression into a string using parentheses:
\begin{verbatim}
  julia> "1 + 2 = $(1 + 2)"
  "1 + 2 = 3"
\end{verbatim}
However, you can also interpolate a literal array like this:
\begin{verbatim}
  julia> x = 2; y = 3; z = 5;

  julia> "x,y,z: $[x,y,z]."
  "x,y,z: [2,3,5]."
\end{verbatim}
Both concatenation and string interpolation call the generic \verb|string| function to convert objects into \verb|String| form.
Most non-\verb|String| objects are converted to strings the they are shown in the Julia repl:
\begin{verbatim}
  julia> v = [1,2,3]
  [1,2,3]

  julia> "vector: $v"
  "vector: [1,2,3]"
\end{verbatim}
\verb|String|s and \verb|Char|s are interpolated as themselves:
\begin{verbatim}
  julia> c = 'x'
  'x'

  julia> "hi, $c"
  "hi, x"
\end{verbatim}
Another useful string function is \verb|repeat|:
\begin{verbatim}
  julia> repeat(".:Z:.", 10)
  ".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."
\end{verbatim}
You can lexicographically compare strings using the standard comparison operators:
\begin{verbatim}
  julia> "abracadabra" < "xylophone"
  true

  julia> "abracadabra" == "xylophone"
  false

  julia> "Hello, world." != "Goodbye, world."
  true

  julia> "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
  true
\end{verbatim}
You can search for the index of a particular character using the \verb|strchr| function:
\begin{verbatim}
  julia> strchr("xylophone", 'x')
  1

  julia> strchr("xylophone", 'p')
  5

  julia> strchr("xylophone", 'z')
  char not found
\end{verbatim}
You can start the search for a character at a given offset by providing a third argument:
\begin{verbatim}
  julia> strchr("xylophone", 'o')
  4

  julia> strchr("xylophone", 'o', 5)
  7

  julia> strchr("xylophone", 'o', 8)
  char not found
\end{verbatim}
Some other useful functions include:
\begin{itemize}
\item \verb|length(str)| gives the maximal (byte) index that can be used to index into \verb|str|.

\item \verb|strlen(str)| the number of characters in \verb|str|.
This is \emph{not} the same as \verb|length(str)|, but we do always have the identity \verb|strlen(str)| $\le$ \verb|length(str)|.

\item \verb|i = start(str)| gives the first valid index at which a character can be found in \verb|str| (typically 1).

\item \verb|c, j = next(str,i)| returns next character at or after the index \verb|i| and the next valid character index following that.
With the \verb|start| and \verb|length|, can be used to iterate through the characters in \verb|str|.

% TODO: figure this out and fix it.

\item \verb|c, j = prev(str,i)| returns the character at or before index \verb|i| and the index at which it occurs.
With \verb|length| and \verb|start| can be used to iterate through the characters in \verb|str| in reverse.

\item \verb|ind2chr(str,i)| gives the number of characters in \verb|str| up to and including any at index \verb|i|.

\item \verb|chr2int(str,j)| gives the index at which the \verb|j|th character in \verb|str| occurs.
\end{itemize}

\subsection{String Internals}

What is the actual type and structure a string object?
\begin{verbatim}
  julia> dump("Hello, world.\n")
  Latin1String(data=[104,101,108,108,111,...,119,111,114,108,100],)
\end{verbatim}
Standard string literals like the above always produce either a \verb|Latin1String| or a \verb|UTF8String|.
Both of these types of strings are implemented using a byte array encoding \verb|Char| values.
\verb|Latin1String| uses a fixed-width, single-byte encoding, while \verb|UTF8String| uses the variable-width, UTF-8 encoding.

Here are the actual declarations of the basic string types from Julia's bootstrapping code:
\begin{verbatim}
  abstract String

  type Latin1String <: String
      data::Array{Uint8,1}
  end

  type UTF8String <: String
      data::Array{Uint8,1}
  end
\end{verbatim}
\verb|String| is an abstract supertype, which is used to refer to all concrete implementations of the string interface.
The \verb|Latin1String| and \verb|UTF8String| classes are both thin wrappers around an array of bytes (\verb|Uint8| values), holding the string's encoded data.
The only difference is in their interpretation:
\begin{enumerate}
\item In a \verb|Latin1String|, bytes and characters are one-to-one, and each byte encodes its Unicode code point directly, the way classic C strings do.
As you may have guessed, this encoding is called Latin-1.
\item In a \verb|UTF8String|, bytes and characters are not one-to-one, but instead uses the UTF-8 encoding, which matches ASCII and Latin-1 up to \verb|0x7f|, and uses two, three of four bytes to encode Unicode characters with higher code points.
\end{enumerate}
How does one generate a \verb|UTF8String| object rather than a \verb|Latin1String| object?
One does so just by using a Unicode character escape sequence above \verb|0x7f| in a string literal:
\begin{verbatim}
  julia> "\u2200 x \u2203 y > x"
  "∀ x ∃ y > x"

  julia> dump(ans)
  UTF8String(data=[226,136,128,32,120,...,121,32,62,32,120],)
\end{verbatim}
Also, absent other indications, external text input is assumed to be encoded as UTF-8, and therefore creates \verb|UTF8String| objects.
String literals created in Julia without escapes, however, can be safely represented using Latin-1, which, being a fixed-width encoding, has much better performance characteristics than UTF-8.
In particular, \verb|Latin1String|s have zero decoding overhead because each character is represented directly by its byte value.
Therefore, Julia uses \verb|Latin1String|s internally whenever it can.

Because there are so many different ways a sequence of characters can be represented, Julia has many different string types, each with a different underlying implementation.
Also, programmers can easily define their own new string types.
The distinction between different string implementations is transparent to the casual observer in Julia.
You can perform string operations with all combinations of types of strings, and they will work:
all string functions are implemented generically in terms of a minimal core set of methods which any string must provide.

Generic implementations of string methods are often less efficient than optimal.
Julia's dispatch system fortunately makes it simple to provide specialized, fast methods in cases where the specific representation of a string can be leveraged somehow.
The typical user never needs to think about this:
just call the right generic function and the work will be dispatched to the appropriate method.
Consider, for example, comparing the lexicographic ordering of two strings:
\begin{verbatim}
  julia> "abracadabra" < "xylophone"
  true
\end{verbatim}
There is a generic string \verb|<| method which can compare any two strings, character by character, regardless of encoding or implementation.
In this case, however, both strings are \verb|Latin1String| objects, and a much faster method of comparison exists:
the \verb|libc| library's \verb|memcmp| function.
So a specialized \verb|<| method is provided to compare two \verb|Latin1String|s using this much faster method.
The usage is completely transparent, however:
regardless of what kinds of strings you have, you simply call \verb|a < b| to compare them.
If \verb|memcmp| can be used, it will be;
if not, the comparison will work, albeit not quite as quickly.
The same trick applies to comparing a pair of \verb|UTF8String|s:
UTF-8 is carefully designed to allow using \verb|memcmp|.

Allowing many different string representations to coexist and interoperate smoothly provides significant flexibility and power.
For example, Julia performs string concatenation using ropes:
\begin{verbatim}
  julia> strcat("foo","bar")
  "foobar"

  julia> dump(ans)
  RopeString(head="foo",tail="bar",depth=1,length=6,)
\end{verbatim}
This makes concatenation, which is by far one of the most common string operations, take $\O(1)$ time rather than $O(n)$ time, as it does if a new memory buffer must be allocated and both strings copied into it.
Another very useful operation is repeating a string:
\begin{verbatim}
  julia> zzz = repeat(".:Z:.", 100000);

  julia> strlen(zzz)
  500000

  julia> zzz[end>>1-15:end>>1+16]
  "..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.."
\end{verbatim}
In julia this requires very little memory because the repeat operation just creates a special kind of string:
\begin{verbatim}
  julia> dump(zzz)
  RepString(string=".:Z:.",repeat=100000,)
\end{verbatim}
The resulting object behaves as though you had a 5MB string in memory, but does so using mod operations when indexing rather than by actually allocating 5MB.
If you actually want to allocate all that memory, you can force Julia to do so by coercing the \verb|RepString| into a byte-backed ``C string'':
\begin{verbatim}
  julia> zzz = cstring(zzz);

  julia> typeof(zzz)
  Latin1String
\end{verbatim}

\section{I/O}
\section{Data Structures}
\subsection{Hash Tables}
\subsection{Sets}
\subsection{Queues and Dequeues}
\subsection{Trees}
\subsection{Lists}

\section{Parallel Computing}
\begin{itemize}
  \item \verb|Worker()| ---
     create a new local worker

  \item \verb|remote_apply(w, func, args...)| ---
     tell a worker to call a function on the given arguments.
     for now, functions are passed as symbols, e.g. \verb|:randn|
     returns a Future.

   \item \verb|wait(f)| ---
     wait for, then return the value represented by a Future

   \item \verb|pmap(pool, func, lst)| ---
     call a function on each element of \verb|lst| (some 1-d thing), in
     parallel. pool is a list of available Workers.

   \item \verb|send_msg(socket, x)| ---
     send a Julia object through a socket

   \item \verb|recv_msg(socket)| ---
     read the next Julia object from a socket
\end{itemize}

\section{Calling C Functions}
\section{Running External Programs}

% Perl, Python, and Ruby are well known for their ability to easily run and interact with other programs.
% In Perl and Ruby, backticks provide a powerful and simple way to call a program and capture its output as as a string:
% \begin{verbatim}
%   #!/usr/bin/env perl
%   $greeting = `echo -n hello`;
%   print "$greeting, world.\n";
% \end{verbatim}
% In this rather simplistic example, the \verb|echo| program prints the string \verb|"hello"| and that output is captured into the variable \verb|$greeting|.
% Arbitrary shell commands can be spawned in backticks because backticks actually spawn a shell to interpret and run these commands.
% Thus, much of the power of this approach comes from the shell---the programming language just spawns the shell and arranges to capture the output.
% You can pass data to the programs spawned by interpolating values into the shell command:
% \begin{verbatim}
%   #!/usr/bin/env perl
%   $sorted = `sort -n $file`;
% \end{verbatim}
% Here things become a bit dangerous:
% if the value of the variable \verb|$file| contains characters that are specially interpreted by the shell, they will be.
% For example, if \verb|$file| is the string \verb|"/Volumes/External HD/data.csv"|, then the above command will attempt to sort the contents of two files named \verb|/Volumes/External| and \verb|HD/data.csv|, which are likely to either not exist, or possibly worse, not be the intended files.
% 
% There are two approaches one can take to address this issue: escape all the shell metacharacters in the the string \verb|$file| before interpolating it, or avoid using the shell by calling a lower level function like \verb|exec|.
% Both Perl and Ruby provide some ability to start a program and then read from its output file descriptor, but these approaches rapidly become quite cumbersome.
% Shell metacharacter escaping is provided by some third party modules, but is not a standard part of the installation of any of the scripting languages, and is hard to get right:
% the shell itself has a lot of complexity and syntax.
% In practice, programmers calling external programs simply tend to just hope that there are no strange characters in their file names.
% A few of the more paranoid will wrap arguments in single quotes within the backticks, writing \verb|`sort -n '$file'`|.
% This, however, is quite ugly, annoying, and worst of all, doesn't actually fix the problem.
% 
% Julia takes the second approach:
% instead of calling a shell to spawn external commands, Julia performs all the tricky UNIX pipe plumbing for you.
% Moreover, it allows you to easily create pipelines \emph{in Julia} where one command pipes output to another.
% In essence, Julia aims to be a better shell than the shell.

Julia borrows backtick notation for commands from shells, Perl, and Ruby.
However, in Julia, writing
\begin{verbatim}
  julia> `echo hello`
  `echo hello`
\end{verbatim}
differs in a several aspects from the behavior in shells, Perl, or Ruby:
\begin{itemize}

\item Instead of immediately running the command, backticks create a \verb|Cmd| object to represent the command.
You can use this \verb|Cmd| object to connect this command to others via UNIX pipes, run it, write to it and read from it.

\item When the command is run, Julia does not capture its output unless you specifically arrange for it to.
Rather, the output of the command by default goes to \verb|stdout| as it would using \verb|libc|'s \verb|system| call.

\item The command is never run with a shell.
Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax.
The command is run as \verb|julia|'s immediate child process, using \verb|fork| and \verb|exec| calls.

\end{itemize}
Here's a simple example of actually running an external program:
\begin{verbatim}
  julia> run(`echo hello`)
  hello
  true
\end{verbatim}
The \verb|hello| is the output of the \verb|echo| command, while the \verb|true| is the return value of the command, indicating that it succeeded.
(These are colored differently by the repl if your terminal supports color.)

\subsection{Interpolation}

Suppose you want to do something a bit more complicated and use the name of a file in the variable \verb|file| as an argument to a command.
You can use \verb|$| for interpolation much as you would in a string literal:
\begin{verbatim}
  julia> file = "/etc/passwd"
  "/etc/passwd"

  julia> `sort $file`
  `sort /etc/passwd`
\end{verbatim}
A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior.
Suppose, for example, rather than \verb|/etc/passwd|, we wanted to sort the contents of the file \verb|/Volumes/External HD/data.csv|.
Let's try it:
\begin{verbatim}
  julia> file = "/Volumes/External HD/data.csv"
  "/Volumes/External HD/data.csv"

  julia> `sort -n $file`
  `sort -n '/Volumes/External HD/data.csv'`
\end{verbatim}
How did the file name get quoted?
Julia knows that \verb|file| is meant to be interpolated as a single argument, so it quotes the word for you.\footnote{This not quite accurate:
the value of \texttt{file} is never interpreted by a shell, so there's no need for actual quoting.
The quotes are inserted only for presentation to the user such that you can cut and paste it back into the repl.}
This will even work if you interpolate a value as part of a shell word:
\begin{verbatim}
  julia> path = "/Volumes/External HD"
  "/Volumes/External HD"

  julia> name = "data"
  "data"

  julia> ext = "csv"
  "csv"

  julia> `sort $path/$name.$ext`
  `sort '/Volumes/External HD/data.csv'`
\end{verbatim}
But what if you \emph{want} to interpolate multiple words?
Just use an array (or any other iterable container):
\begin{verbatim}
  julia> files = ["/etc/passwd","/Volumes/External HD/data.csv"]
  ["/etc/passwd","/Volumes/External HD/data.csv"]

  julia> `grep foo $files`
  `grep foo /etc/passwd '/Volumes/External HD/data.csv'`
\end{verbatim}
If you interpolate an array as part of a shell word, Julia emulates the shell \verb|{a,b,c}| shell generation behavior:
\begin{verbatim}
  julia> names = ["foo","bar","baz"]
  ["foo","bar","baz"]

  julia> `grep xylophone $names.txt`
  `grep xylophone foo.txt bar.txt baz.txt`
\end{verbatim}
If you interpolate multiple arrays, the shell's Cartesian product generation behavior is emulated:
\begin{verbatim}
  julia> names = ["foo","bar","baz"]
  ["foo","bar","baz"]

  julia> exts = ["aux","log"]
  ["aux","log"]

  julia> `rm -f $names.$exts`
  `rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{verbatim}
Since you can interpolate literal arrays, you can easily use this generative functionality without needing to create temporary array objects first:
\begin{verbatim}
  julia> `rm -rf ${"foo","bar","baz"}.${"aux","log"}`
  `rm -rf foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{verbatim}

\subsection{Quoting}

Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes.
Here's a simple example of a perl one-liner at a shell prompt:
\begin{verbatim}
  $ perl -le '$|=1; for (0..3) { print }'
  0
  1
  2
  3
\end{verbatim}
You need to surround the Perl expression in single quotes for two reasons:
so that spaces don't break the expression into multiple shell words, and so that uses of variables like \texttt{\$|} (yes, that's a variable), don't cause interpolation.
In other instances, you may want to use double quotes so that interpolation \emph{does} occur:
\begin{verbatim}
  $ first="A"
  $ second="B"
  $ perl -le '$|=1; print for @ARGV' "1: $first" "2: $second"
  1: A
  2: B
\end{verbatim}
In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as-is into backticks and they will work.
Let's try the above two examples in Julia:
\begin{verbatim}
  julia> `perl -le '$|=1; for (0..3) { print }'`
  `perl -le '$|=1; for (0..3) { print }'`

  julia> run(ans)
  0
  1
  2
  3
  true

  julia> first = "A"; second = "B";

  julia> `perl -le 'print for @ARGV' "1: $first" "2: $second"`
  `perl -le 'print for @ARGV' '1: A' '2: B'`

  julia> run(ans)
  1: A
  2: B
  true
\end{verbatim}
The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities.
When trying to port shell commands to Julia, try cut and pasting first.
Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.

\subsection{Pipelines}

Shell metacharacters, such as \texttt{|}, \verb|&|, and \verb|>|, are not special inside of Julia's backticks:
unlike in the shell, inside of Julia's backticks, a pipe is always just a pipe:
\begin{verbatim}
  julia> run(`echo hello | sort`)
  hello | sort
  true
\end{verbatim}
This command prints the word ``hello'' followed by a literal pipe character followed by the word ``sort.''
Then how does one construct a pipeline?
Use Julia's \texttt{|} operator on \verb|Cmd| objects instead:
\begin{verbatim}
  julia> run(`echo hello` | `sort`)
  hello
  true
\end{verbatim}
This pipes the output of the \verb|echo| command to the \verb|sort| command.
Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:
\begin{verbatim}
  julia> run(`cut -d: -f3 /etc/passwd` | `sort -n` | `tail -n5`)
  210
  211
  212
  213
  214
  true
\end{verbatim}
This prints the highest five user IDs on a UNIX system.

Another pipelining facility that Julia provides is running multiple commands in parallel:
\begin{verbatim}
  julia> run(`echo hello` & `echo world`)
  world
  hello
  true
\end{verbatim}
The order of the output here is non-deterministic because the two \verb|echo| processes are started nearly simultaneously, and race to make the first write to the \verb|stdout| descriptor they share with each other and the \verb|julia| parent process.
Julia lets you pipe the output from both of these processes to another program:
\begin{verbatim}
  julia> run(`echo world` & `echo hello` | `sort`)
  hello
  world
  true
\end{verbatim}
In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both \verb|echo| processes, and the other end of the pipe is read from by the \verb|sort| command.

The combination of a programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one.
To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples (apologies for excessive Perlage):
\begin{verbatim}
  prefixer(prefix, sleep) =
      `perl -nle '$|=1; print "'$prefix' ", $_; sleep '$sleep';'`

  julia> run(`perl -le '$|=1; for(0..9){ print; sleep 1 }'` |
             prefixer("A",2) & prefixer("B",2))
  A	0
  B	1
  A	2
  B	3
  A	4
  B	5
  A	6
  B	7
  A	8
  B	9
  true
\end{verbatim}
This is a classic example of a single producer feeding two concurrent consumers:
one \verb|perl| process generates lines with the numbers 0 through 9 on them, while two parallel processes process that output, one prefixing lines with the letter ``A,'' the other with the letter ``B.''
Which consumer gets the first line is non-deterministic, but once the race has been one, the lines are consumed alternately by one process and then the other.\footnote{Setting \texttt{\$|=1} in Perl causes each print statement to flush the \texttt{stdout} handle, which is necessary for this example to work.
Otherwise all the output is buffered and printed to the pipe at once, to be read by a single consumer process at once.}

Here is an even more complex multi-stage producer-consumer example:
\begin{verbatim}
  julia> run(`perl -le '$|=1; for(0..9){ print; sleep 1 }'` |
             prefixer("X",3) & prefixer("Y",3) & prefixer("Z",3) |
             prefixer("A",2) & prefixer("B",2))
  B	Y	0
  A	Z	1
  B	X	2
  A	Y	3
  B	Z	4
  A	X	5
  B	Y	6
  A	Z	7
  B	X	8
  A	Y	9
  true
\end{verbatim}
This example works is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.

Finally, we have an example of how you can make a process read from itself:
\begin{verbatim}
  julia> gen = `perl -le '$|=1; for(0..9){ print; sleep 1 }'`
  `perl -le '$|=1; for(0..9){ print; sleep 1 }'`

  julia> dup = `perl -ne '$|=1; warn $_; print ".$_"; sleep 1'`
  `perl -ne '$|=1; warn $_; print ".$_"; sleep 1'`

  julia> run(gen | dup | dup)
  0
  .0
  1
  ..0
  2
  .1
  3
  ...0
  4
  .2
  5
  ..1
  6
  .3
  ....0
  7
  .4
  8
  9
  ..2
  .5
  ...1
  .6
  ..3
  .....0
  .7
  ..4
  .8
  .9
  ...2
  ..5
  ....1
  ..6
  ...3
\end{verbatim}
This example never terminates since the \verb|dup| process reads its own output and duplicates it to \verb|stderr| forever.
We strongly encourage you to try all these examples to see how they work.

\section{Standard Library Reference}

\section{Macros}

Macros are totally different from inlining.
Macros are a hook into the compiler that lets you examine and rewrite the syntax of a piece of the program.
You can use them to implement entirely new syntactic constructs like remote spawn, parallel for loops, string interpolation, pattern matching, Julia's command syntax, etc.

Macros also run at an earlier binding time than functions and so have different semantics.
Inlining moves code around in a way that keeps the same function call semantics, i.e. you can't ``tell'' that it happened.
Macros are just the opposite.
For example, say I have a function that contains an inner function:

\begin{verbatim}
  function foo()
    bar(x) = XXX
    ...
    bar(...)
  end
\end{verbatim}

Now I want to abstract away the definition of \verb|bar|.
Maybe I want to use it in multiple functions and I don't want to copy and paste it.
With macros I can do this:

\begin{verbatim}
  macro definestuff(name)
    quote
      ($name)(x) = XXX
    end
  end

  function foo()
    @definestuff bar
    ...
  end
\end{verbatim}

This is not possible without macros.
If you passed \verb|:bar| to a function, that function has no way to define a local \verb|bar| inside \verb|foo|.
If it used \verb|eval|, it would define a top-level function called \verb|bar|. 
Since the macro runs so much earlier, it can change the code of \verb|foo| itself, so it can easily modify local variables.

And this example hardly shows the full power, since the argument to
the macro is only a symbol.
This is just to show the semantic differences.
Another example is \verb|spawn|:

\begin{verbatim}
  macro spawn(expr)
    quote
      spawn(()->($expr))
    end
  end
\end{verbatim}

Now you can write \verb|@spawn a+b| and it will call a function \verb|spawn| on \verb|a+b| wrapped in a thunk.
This syntax improvement requires macros:
the function call \verb|spawn(a+b)| couldn't work since \verb|a+b| will be fully evaluated before \verb|spawn| is called.
Calling a quoted expression, as in \verb|spawn(:(a+b))|, is ugly and moreover simply wouldn't work since \verb|spawn| cannot use the expression \verb|:(a+b)| by itself to access the values of local variables \verb|a| and \verb|b|.

People often compare macros to inlining (for example, the designer(s) of C++), but this is a pun.
There is only a superficial similarity of inserting code into other code.

\section{Command-Line Options}
\sec{command-line-options}

\begin{verbatim}
  julia [options] [program] [args...]
   -q --quiet               Quiet startup without banner
   -R --no-readline         Disable readline functionality
   -e --eval=<expr>         Evaluate <expr> and don't print
   -E --print=<expr>        Evaluate and print <expr>
   -P --post-boot=<expr>    Evaluate <expr> right after boot
   -H --home=<dir>          Load files relative to <dir>
   -T --tab=<size>          Set REPL tab width to <size>
   -L --lisp                Start with Lisp prompt not Julia
   -b --bare                Bare REPL: don't load start.j
   -h --help                Print this message
\end{verbatim}

\end{document}
