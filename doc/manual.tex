\documentclass{article}

\newcommand{\thetitle}{The Julia Programming Language}

\usepackage{amsmath}
\usepackage[hyperfigures,bookmarks,bookmarksopen,bookmarksnumbered,colorlinks,linkcolor=black,citecolor=black,filecolor=blue,menucolor=black,pagecolor=blue,frenchlinks=true,pdftitle={\thetitle}]{hyperref}
\usepackage[left=1in,top=1in,right=1in,bottom=1.25in,nohead]{geometry}
\usepackage[utf8x]{inputenc}

\title{\thetitle}
\author{
Jeff Bezanson \vspace{0.5em}\\
Stefan Karpinski \vspace{0.5em}\\
Viral Shah \vspace{0.5em}
}

\renewcommand{\sec}[1]{\label{sec:#1}}
\newcommand{\fig}[1]{\label{fig:#1}}
\newcommand{\tab}[1]{\label{tab:#1}}

\newcommand{\Section}[1]{\hyperref[sec:#1]{Section~\ref*{sec:#1}}}
\newcommand{\Figure}[1]{\hyperref[fig:#1]{Figure~\ref*{fig:#1}}}
\newcommand{\Table}[1]{\hyperref[tab:#1]{Table~\ref*{tab:#1}}}

\renewcommand{\bullet}{{$\diamond$}}
\renewcommand{\labelitemi}{\bullet}
\renewcommand{\labelitemii}{\bullet}
\renewcommand{\labelitemiii}{\bullet}

\renewcommand{\O}{\ensuremath{\operatorname{O}}}

\begin{document}

\maketitle

Scientific computing has traditionally required the highest performance, yet domain experts have largely moved to slower dynamic languages for daily work.
We believe there are many good reasons to prefer dynamic languages for these applications, and we do not expect their use to diminish.
Fortunately, modern language design and compiler techniques make it possible to mostly eliminate the performance trade-off and provide a single environment productive enough for prototyping and performant enough for deploying applications.
The Julia programming language fills this role:
it is a flexible and dynamic language, designed expressly for scientific computing, and achieving performance comparable to traditional compiled languages.

The syntax of Julia is directly derived from Matlab, and consequently, any Matlab programmer should feel immediately comfortable with Julia.
While Matlab is quite effective for prototyping and exploring numerical linear algebra, for programming tasks outside of this relatively narrow scope, Matlab has severe limitations.
Julia maintains the ease and expressiveness of Matlab for high-level numerical computing, but transcends its general programming limitations.
To that end, it borrows heavily from the C programming language, but it is also strongly influenced by the lineage of dynamic languages:
Lisp, Perl, Python and Ruby.

\section{Getting Started}
\sec{getting-started}

\subsection{How to Obtain and Install Julia}
\sec{obtaining-and-installing}

\subsection{Running Code}
\sec{running-code}

Here's how you start and interact with the Julia read-eval-print loop (repl):

\begin{verbatim}
  $ julia
                 _      
     _       _ _(_)_     |
    (_)     | (_) (_)    |  
     _ _   _| |_  __ _   |
    | | | | | | |/ _` |  |
    | | |_| | | | (_| |  |  2009-2010 contributors
   _/ |\__'_|_|_|\__'_|  |  
  |__/                   |

  julia> 1 + 2
  3

  julia> load("file.j");
\end{verbatim}
The \verb|load| function reads and evaluates the contents of the given file.
The \verb|julia| program takes a variety of command-line options, similar to the \verb|perl| and \verb|ruby| programs.
See \Section{command-line-options} for details.
The semicolon at the end of a repl line suppresses output of the expression value.

\section{Numbers and Arithmetic}
Julia supports a broad range of numeric types together with the full complement of arithmetic and bitwise operations.
The following are Julia's built-in primitive numeric types:

\begin{itemize}
  \item integer types:
  \begin{itemize}
    \item \verb|Int8|~: signed 8-bit integers ranging from $-2^7$ to $2^7-1$.
    \item \verb|Uint8|~: unsigned 8-bit integers ranging from 0 to $2^8-1$.
    \item \verb|Int16|~: signed 16-bit integers ranging from $-2^{15}$ to $2^{15}-1$.
    \item \verb|Uint16|~: unsigned 16-bit integers ranging from 0 to $2^{16}-1$.
    \item \verb|Int32|~: signed 32-bit integers ranging from $-2^{31}$ to $2^{31}-1$.
    \item \verb|Uint32|~: unsigned 32-bit integers ranging from 0 to $2^{32}-1$.
    \item \verb|Int64|~: signed 64-bit integers ranging from $-2^{63}$ to $2^{63}-1$.
    \item \verb|Uint64|~: unsigned 64-bit integers ranging from 0 to $2^{64}-1$.
  \end{itemize}
  \item floating point types:
  \begin{itemize}
    \item \verb|Float32|~: IEEE 754 32-bit floating point numbers.
    \item \verb|Float64|~: IEEE 754 64-bit floating point numbers.
  \end{itemize}
\end{itemize}

\subsection{Integer Literals}

The default type for an integer literal is \verb|Int32|:
\begin{verbatim}
  julia> typeof(1)
  Int32
\end{verbatim}
Larger integer literals that cannot be represented in 32 bits but that can be represented in 64 bits will create 64-bit integers:
\begin{verbatim}
  julia> typeof(4294967296)
  Int64
\end{verbatim}
Integers can be input in hexadecimal form using the \verb|0x| prefix as in C:
\begin{verbatim}
  julia> 0xff
  255

  julia> typeof(ans)
  Int32

  julia> 0xffffffff
  4294967295

  julia> typeof(ans)
  Int64
\end{verbatim}
There is no literal input format for integer types besides \verb|Int32| and \verb|Int64|. You can, however convert \verb|Int32| and \verb|Int64| values to other types easily:
\begin{verbatim}
  julia> int8(-15)
  -15

  julia> typeof(ans)
  Int8

  julia> uint8(231)
  231

  julia> typeof(ans)
  Uint8
\end{verbatim}

\subsection{Floating Point Literals}

Floating point numbers are input in the standard formats:
\begin{verbatim}
  julia> 1.0
  1.0

  julia> 1.
  1.0

  julia> 0.5
  0.5

  julia> .5
  0.5

  julia> -1.23
  -1.23

  julia> 1e10
  1e+10

  julia> 2.5e-4
  0.00025
\end{verbatim}
The above results are all \verb|Float64| values. There is no literal format for \verb|Float32|, but you can convert values to \verb|Float32| easily:
\begin{verbatim}
  julia> float32(-1.5)
  -1.5

  julia> typeof(ans)
  Float32
\end{verbatim}
There are three specified standard floating point values that do not correspond to a point on the real number line: plus infinity, minus infinity, and not-a-number (NaN).
Here are their literal input forms:
\begin{verbatim}
  julia> Inf
  Inf

  julia> -Inf
  -Inf

  julia> NaN
  NaN
\end{verbatim}
By the IEEE 754 standard, these floating point values are the results of certain arithmetic operations:
\begin{verbatim}
  julia> 1/0
  Inf

  julia> -5/0
  -Inf

  julia> 0.000001/0
  Inf

  julia> 0/0
  NaN

  julia> 500 + Inf
  Inf

  julia> 500 - Inf
  -Inf

  julia> Inf - Inf
  NaN

  julia> Inf/Inf
  NaN
\end{verbatim}

\subsection{Arithmetic and Bitwise Operations}

The following arithmetic and bitwise operations are supported on built-in arithmetic types:
\begin{itemize}
  \item arithmetic operations (integer and floating point):
  \begin{itemize}
    \item \verb|+x|~: unary plus is the identity operation.
    \item \verb|-x|~: unary minus maps values to their additive inverses.
    \item \verb|x + y|~: plus performs addition.
    \item \verb|x - y|~: binary minus performs subtraction.
    \item \verb|x * y|~: times performs multiplication.
    \item \verb|x / y|~: divide performs division.
  \end{itemize}
  \item bitwise operations (integer only)\,:
  \begin{itemize}
    \item \verb|~x|~: bitwise not.
    \item \verb|x & y|~: bitwise and.
    \item \texttt{x | y}~: bitwise or.
    \item \verb|x $ y|~: bitwise xor.
    \item \verb|x << y|~: logical shift left.
    \item \verb|x >> y|~: logical shift right.
    \item \verb|x >>> y|~: arithmetic shift right.
  \end{itemize}
\end{itemize}
Here are some simple examples:\,\footnote{By convention, we tend to space less tightly binding operations less tightly, but there are no syntactic constraints.}
\begin{verbatim}
  julia> 1 + 2 + 3
  6

  julia> 1 - 2
  -1

  julia> 3*2/12
  0.5
\end{verbatim}
Julia has a powerful and flexible type promotion system that allows arithmetic operations on mixtures of argument types to work naturally:
\begin{verbatim}
  julia> 1 + 2.5
  3.5

  julia> 0.5*12
  6.0

  julia> 3*2/12 + 1
  1.5
\end{verbatim}
The above operations all promote to \verb|Float64|s since that is the smallest floating point type that can faithfully represent all \verb|Int32| values.
However, more nuanced promotions also work:
\begin{verbatim}
  julia> uint8(12) - int8(15)
  -3

  julia> typeof(ans)
  Int16

  julia> uint8(12) - float32(1.5)
  10.5

  julia> typeof(ans)
  Float32
\end{verbatim}
Here are some examples with bitwise operations:
\begin{verbatim}
  julia> ~123
  -124

  julia> ~uint32(123)
  4294967172

  julia> ~uint8(123)
  132

  julia> 123 & 234
  106

  julia> 123 | 234
  251

  julia> typeof(ans)
  Int32

  julia> uint8(123) | uint16(234)
  251

  julia> typeof(ans)
  Uint16

  julia> 123 $ 234
  145
\end{verbatim}
As a general rule of thumb, arguments are promoted to the smallest type that can accurately represent all of the arguments. See \Section{conversion-and-promotion} for further details.

\subsection{Numeric Literal Coefficients}

To make common numeric formulas and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication.
This makes writing polynomial expressions much cleaner:
\begin{verbatim}
  julia> x = 3
  3

  julia> 2x + 1
  7

  julia> 2x^2 - 3x + 1
  10

  julia> 1.5x^2 - .5x + 1
  13.0
\end{verbatim}
Juxtaposed numeric coefficients conflict with two numeric literal syntaxes:
hexadecimal integer literals and engineering notation for floating point literals:
\begin{itemize}
\item For example, the hexadecimal integer literal expression \verb|0xff| could also be interpreted as the numeric literal \verb|0| multiplied by the variable \verb|xff|.
\item Likewise, the floating point literal expression \verb|1e10| could be interpreted as the numeric literal \verb|1| multiplied by the variable \verb|e10|, and similarly with the equivalent \verb|E| form.
\end{itemize}
In both cases, we resolve the ambiguity in favor of the numeric literals:
\begin{itemize}
\item Expressions starting with \verb|0x| are always hexadecimal literals.
\item Expressions starting with $d.dd$\,\verb|e| or $d.dd$\,\verb|E| are always floating point literals.
\end{itemize}

\subsection{Numeric Comparisons}

Standard comparison operations are defined for primitive numeric types:
\begin{itemize}
  \item \verb|==|~: equality.
  \item \verb|!=|~: inequality.
  \item \verb|<|~: less than.
  \item \verb|<=|~: less than or equal to.
  \item \verb|>|~: greater than.
  \item \verb|>=|~: greater than or equal to.
\end{itemize}
Here are some simple examples:
\begin{verbatim}
  julia> 1 == 1
  true

  julia> 1 == 2
  false

  julia> 1 != 2
  true
  
  julia> 1 == 1.0
  true

  julia> 1 < 2
  true

  julia> 1.0 > 3
  false

  julia> 1 >= 1.0
  true

  julia> -1 <= 1
  true

  julia> -1 <= -1
  true

  julia> -1 <= -2
  false

  julia> 3 < -0.5
  false
\end{verbatim}
As is evident here, promotion also applies to comparisons:
the comparisons are performed in whatever type the arguments are promoted to, which is generally the smallest type in which all the values can be faithfully represented.

After promotion to a common type, integers are compared in the standard manner:
by comparison of bits.
Floating point numbers are compared according to the IEEE 754 standard:
finite numbers are compared bitwise and given their usual ordering;
positive infinite values are equal to each other and greater than everything else besides \verb|NaN|;
negative infinite values are equal to each other and less then everything else besides \verb|NaN|;
\verb|NaN| is not equal to, less than, or greater than anything, including itself:
\begin{verbatim}
  julia> NaN == NaN
  false

  julia> NaN != NaN
  true

  julia> NaN < NaN
  false

  julia> NaN > NaN
  false
\end{verbatim}
For situations where one wants to compare floating point values in such a way that \verb|NaN == NaN|, e.g. hash key comparisons, the function \verb|isequal| is also provided, which considers \verb|NaN|s to be equal:
\begin{verbatim}
  julia> isequal(NaN,NaN)
  true
\end{verbatim}
Unlike most languages, comparisons can be arbitrarily chained:
\begin{verbatim}
  julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
  true
\end{verbatim}
Chaining comparisons is quite convenient in many numerical codes.

\subsection{Rational Numbers}

Rational numbers can be constructed using the \texttt{//} operator:
\begin{verbatim}
  julia> 2//3
  2//3

  julia> typeof(ans)
  Rational{Int32}
\end{verbatim}
The type of a rational number is a parametric type, a concept explained in detail later in \Section{struct-constructors}.
For the moment, it suffices to say that \verb|2//3| is a ratio of \verb|Int32| values.
If you construct a \verb|Rational| from values that are not in lowest terms, they will be normalized to lowest terms:
\begin{verbatim}
  julia> 6//9
  2//3

  julia> -4//8
  -1//2

  julia> 5//-15
  -1//3

  julia> -4//-12
  1//3
\end{verbatim}
All arithmetic operations are also defined on \verb|Rational|s:
\begin{verbatim}
  julia> 2//4 + 1//6
  2//3

  julia> 5//12 - 1//4
  1//6

  julia> 5//8 * 3//12
  5//32

  julia> 6//5 / 10//7
  21//25
\end{verbatim}
\verb|Rational|s can be easily converted to floating point numbers:
\begin{verbatim}
  julia> float(3//4)
  0.75
\end{verbatim}
All such conversions obey the following identity for all integral \verb|a| and \verb|b|:
\begin{verbatim}
  julia> isequal(float(a//b), a/b)
  true
\end{verbatim}
This includes cases where \verb|a == 0| or \verb|b == 0|, in which situations the conversion from rational to float produces the appropriate $\pm$\verb|Inf| or \verb|NaN| value:
\begin{verbatim}
  julia> 5//0
  1//0

  julia> float(5//0)
  Inf

  julia> isequal(float(5//0), 5/0)
  true

  julia> 0//0
  0//0

  julia> float(0//0)
  NaN

  julia> isequal(float(0//0), 0/0)
  true

  julia> -3//0
  -1//0

  julia> float(-3//0)
  -Inf

  julia> isequal(float(-3//0), -3/0)
  true
\end{verbatim}
In a sense, Julia \verb|Rational|s are a convenient way of deferring the computation of integer ratios, thereby avoiding the accumulation of floating point errors.

\subsection{Complex Numbers}

\section{Control Flow}



\section{Functions}

The basic syntax for defining functions in Julia is:
\begin{verbatim}
  function f(x,y)
    x + y
  end
\end{verbatim}
This syntax is similar to Matlab, but there are some significant differences:
\begin{itemize}
\item In Matlab, this definition must be saved in a file, named \verb|f.m|.
In Julia, this expression can appear anywhere, including at the repl prompt.
\item In Matlab, the closing \verb|end| is optional, being implied by the end of the file.
In Julia, the terminating \verb|end| is required.
\item in Matlab, this function would print the value $x + y$ but would not return any value.
In Julia, the last expression evaluated is a function's return value.
\item Expression values are never printed automatically except in the repl.
Semicolons are only required to separate expressions on the same line.
\end{itemize}
In general, while the function definition syntax is reminiscent of Matlab, the similarity is largely superficial.
Therefore, rather than continually comparing the two, in what follows, we will simply describe the behavior of functions in Julia directly.

There is a second, more terse syntax for defining a function in Julia.
The traditional function declaration syntax demonstrated above is equivalent to the following compact ``assignment form'':
\begin{verbatim}
  f(x,y) = x + y
\end{verbatim}
In the assignment form, the body of the function must be a single expression, although it can be a complex compound expression.
Short, simple function definitions are common in Julia.
The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.

\subsection{The \texttt{return} Keyword}

The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition.
In the example function, \verb|f|, this is simply the value of the expression \verb|x + y|.
As in C, and most other imperative or functional languages, the \verb|return| keyword can cause the function to return from any point, optionally providing an expression whose value is returned:
\begin{verbatim}
  function g(x,y)
    return x * y
    x + y
  end
\end{verbatim}
Since functions definitions can be entered directly into the repl, it is easy to try these definitions out to compare them:
\begin{verbatim}
  julia> function g(x,y)
           return x * y
           x + y
         end
  Methods for generic function g
  g(Any,Any)

  julia> g(2,3)
  6

  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(2,3)
  5
\end{verbatim}
Of course, in a purely linear function body like \verb|g|, the usage of \verb|return| is pointless since the expression \verb|x + y| is never evaluated and we could simply make \verb|x * y| the last expression in the function and omit the \verb|return|.
In conjunction with other control flow, however, \verb|return| is of real use.
Here, for example, is a function that computes the hypotenuse length of a right triangle with sides of length $x$ and $y$, carefully avoiding overflow of intermediate results:
\begin{verbatim}
  function hypot(x,y)
      x = abs(x)
      y = abs(y)
      if x > y
          r = y/x
          return x*sqrt(1+r*r)
      end
      if y == 0
          return zero(x)
      end
      r = x/y
      return y*sqrt(1+r*r)
  end
\end{verbatim}
There are three possible points of return from this function, returning the values of three different expressions, depending on the values of $x$ and $y$.
The \verb|return| on the last line could be omitted since it is the last expression.

\subsection{Variable Scope and Declarations}

\subsection{Specializing Functions for Given Types}

Julia allows multiple dispatch based on the types of function arguments:
\begin{verbatim}
  f(x,y) = x + y
  f(x::Float64, y::Float64) = x * y
\end{verbatim}
The appropriate version will be called based on the types of the argument values:
\begin{verbatim}
  julia> f(2,3)
  5

  julia> f(2.0,3.0)
  6.0
\end{verbatim}
Dispatch is done on all argument types and the most specific method that applies is called:
\begin{verbatim}
  julia> f(2,3.0)
  5.0
\end{verbatim}
Here, the second method of \verb|f| cannot be applied since \verb|2| is not a \verb|Float64|.
In the first method, the argument types are unconstrained, so this serves as a catchall method, and is called here.

If you've been entering these definitions in the repl, you'll have noticed that it shows you all the methods defined for a given ``generic function'' when a new method is defined or if you ask the repl to show the function object:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y::Float64) = x * y
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)

  julia> f
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)
\end{verbatim}
The \verb|Any| type is the default when no type is specified:
all Julia objects match \verb|Any|.
In formal type system literature, \verb|Any| is commonly called Top.\footnote{Julia also has a Bottom type called \texttt{None} which no object matches.}

Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language.
Core operations typically have dozens of methods defined:
\begin{verbatim}
  julia> +
  Methods for generic function +
  +(Real,Range{T<:Real})
  +(Real,Range1{T<:Real})
  +(Union(Range{T<:Real},Range1{T<:Real}),Real)
  +(Union(Range{T<:Real},Range1{T<:Real}),
    Union(Range{T<:Real},Range1{T<:Real}))
  +()
  +(Number,)
  +(Any,Any,Any)
  +(Any,Any,Any,Any)
  +(Any,Any,Any,Any,Any)
  +(Any,Any,Any,Any...)
  +(Int8,Int8)
  +(Int16,Int16)
  +(Int32,Int32)
  +(Int64,Int64)
  +(Uint8,Uint8)
  +(Uint16,Uint16)
  +(Uint32,Uint32)
  +(Uint64,Uint64)
  +(Float32,Float32)
  +(Float64,Float64)
  +(Char,Char)
  +(Rational{T<:Int},Rational{T<:Int})
  +(Complex{T<:Real},Complex{T<:Real})
  +(T<:Number,T<:Number)
  +(Number,Number)
  +(Tensor{T<:Number,N},)
  +(Tensor{S,N},Tensor{T,N})
  +(Number,Tensor{T,N})
  +(Tensor{T,N},Number)
\end{verbatim}
Multiple dispatch together with the flexible parametric type system, give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient specialized code at run time.

\subsection{Method Ambiguities}

It is possible to define a set of function methods such that ambiguous cases exist where for some combinations of argument types there is no unique most specific method which applies:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y) = 2x + y
  Methods for generic function f
  f(Float64,Any)
  f(Any,Any)

  julia> f(x, y::Float64) = x + 2y
  Warning: new definition f(Any,Float64) is ambiguous with
  f(Float64,Any). Make sure f(Float64,Float64) is also defined.
  Methods for generic function f
  f(Float64,Any)
  f(Any,Float64)
  f(Any,Any)

  julia> f(2,3)
  5

  julia> f(2.0,3)
  7.0

  julia> f(2,3.0)
  8.0

  julia> f(2.0,3.0)
  7.0
\end{verbatim}
Here the arguments \verb|2.0| and \verb|3.0| could be handled by either the \verb|f(Float64,Any)| or the \verb|f(Any,Float64)| method, and neither is more specific than the other.
In such cases, Julia warns you about this ambiguity, but allows you to proceed, arbitrarily picking a method.
You should avoid method ambiguities by specifying an appropriate method for the intersection case:
\begin{verbatim}
  julia> f(x,y) = x + y
  Methods for generic function f
  f(Any,Any)

  julia> f(x::Float64, y::Float64) = 2x + 2y
  Methods for generic function f
  f(Float64,Float64)
  f(Any,Any)

  julia> f(x::Float64, y) = 2x + y
  Methods for generic function f
  f(Float64,Float64)
  f(Float64,Any)
  f(Any,Any)

  julia> f(x, y::Float64) = x + 2y
  Methods for generic function f
  f(Float64,Float64)
  f(Float64,Any)
  f(Any,Float64)
  f(Any,Any)

  julia> f(2,3)
  5

  julia> f(2.0,3)
  7.0

  julia> f(2,3.0)
  8.0

  julia> f(2.0,3.0)
  10.0
\end{verbatim}
To suppress Julia's warning, the disambiguating method must be defined first.

\subsection{Functional Equivalents of Operators}
\subsection{Anonymous Functions}
\subsection{Returning Multiple Values}
\subsection{Varargs Functions}


\section{Defining Types}
\subsection{Tag Types}
\subsection{Struct Types}

Julia comes with pre-defined rational and complex numeric types, but they are just defined in the language in terms of the more basic numeric types given above using the standard facility for defining new types. For example, the declaration of the \verb|Rational| type is the following:
\begin{verbatim}
  struct Rational{T<:Int} <: Real
    num::T
    den::T
  end
\end{verbatim}
A few facts are in order before you can understand this declaration:
\begin{itemize}
\item A \verb|struct| type is a named bundle of fields as in the C language. In this case the fields are \verb|num| and \verb|den| which are used to store the numerator and the denominator, respectively, of a rational number.
\item The \verb|Rational{T}| syntax is used for parametric types. This declaration defines \verb|Rational| with respect to a type parameter, \verb|T|.
\item The \verb|<:| operator asserts that the value on the left is a subtype of the value on the right. In this case it is used twice:
  \begin{itemize}
    \item to assert that the type parameter, \verb|T|, is a subtype of \verb|Int|, which includes all of the above integer types;
    \item to assert that \verb|Rational| itself is a subtype of \verb|Real|, which includes the integer and floating-point types as well.
  \end{itemize}
\item The \verb|::| operator asserts that the name on the left will be bound to a value of the type on the right. Thus whatever type parameter \verb|T| is given as, the numerator and denominator of the rational number are of that type.
\end{itemize}
This is all somewhat complicated, but the result is easy to use:
\begin{verbatim}
  julia> Rational(1,2)
  1//2

  julia> typeof(ans)
  Rational{Int32}
\end{verbatim}
Applying the \verb|Rational| type to a pair of values (1,2) creates a \verb|Rational|. The output notation 1//2 is also acceptable as input notation:
\begin{verbatim}
  julia> 1//2
  1//2
\end{verbatim}
Despite being effectively user-defined types, \verb|Rational| values interoperate completely with other numeric types:
\begin{verbatim}
  julia> 1//2 + 2
  5//2

  julia> 1//2 + 1.5
  2.0
\end{verbatim}
If you want to create an ``exotic'' rational object of a type like \verb|Rational{Uint8}| all you need to do is use \verb|Uint8| values to construct them:
\begin{verbatim}
  julia> uint8(123)//uint8(234)
  41//78

  julia> typeof(ans)
  Rational{Uint8}
\end{verbatim}
If you use mixed types to construct a \verb|Rational|, the same promotions that are used for arithmetic apply:
\begin{verbatim}
  julia> uint8(123)//int8(-12)
  -41//4

  julia> typeof(ans)
  Rational{Int16}
\end{verbatim}

\subsection{Struct Constructors}
\sec{struct-constructors}

\subsection{Bits Types}

\subsection{Conversion and Promotion}
\sec{conversion-and-promotion}

\subsection{Other Kinds of Types}

\section{Tensors and Comprehensions}

Julia introduces a new programming construct called a multidimensional
array comprehension or just an array comprehension for short. Array
comprehensions are similar to the notion of list comprehensions in
other languages such as Python, Haskell and OCaml, but extend this
notion to manipulate and generate arrays of arbitrary dimension. Each
dummy variable used in the array comprehension corresponds to a
dimension of the output array; if the comprehension expression value
itself has non-zero dimension then the total dimension of the output
is the number of dummy variables plus the dimension of the value. If
we view n-d arrays as rank-n tensors, and thus see 1-d arrays as
vectors and 2-d arrays as matrices, many common vector, matrix and
tensor operations can be expressed concisely and clearly using array
comprehensions.

Array comprehensions are envisioned to be a key construct of the julia
language that will differentiate it from other languages. On one hand,
Matlab is pretty fast, and it is almost impossible to beat Matlab at
what it does. On the other hand, Matlab codes when rewritten in C
often run 10 times faster. What gives? The key idea behind array
comprehensions is to express almost all operations at a higher level,
close to their mathematical definitions. Optimizations can then be
applied to this high level to produce heavily optimized low-level
code, for multiple comprehensions and compounded comprehensions. This
scheme should allow the generation of optimized low-level code from a
high level specification that matches the structure of optimized C
code written by a good C programmer.

\subsection{Array Comprehension Notations}

The following sections give three increasingly succinct syntaxes for writing array comprehensions. Through the forms, we follow the basic example of how to express the row sum and column sums of a matrix. We first present the most general, verbose notation for array comprehensions together with its meaning, and then present two increasingly abbreviated but equivalent forms.

\subsubsection{Explicit range}
This is the most general form for writing array comprehensions. The general form is:
\begin{verbatim}
A = [ F(x,y,...) | x=rx, y=ry, ... ]
\end{verbatim}

The meaning of this form is that F(x,y,...) is evaluated with the
variables x, y, etc. taking on each value in their given list of
values. Values can be specified as any iterable object, but will
commonly be ranges like 1:n or 2:(n-1), or explicit arrays of values
like [1.2, 3.4, 5.7]. The result is a tensor object with dimensions
that are the concatenation of the dimensions of the dummy variable
ranges rx, ry, etc. and the dimension of the result of each F(x,y,...)
evaluations—which must all have identical shape. See below for details
on array comprehensions of non-scalar expression.

To clarify, let's consider the concrete example of computing row and
column sums of a matrix, A. For a single dummy variable, the array
comprehension notation with explicit variable ranges is similar to
list comprehensions in other languages:
\begin{verbatim}
row_sums = [ sum(A[i,:]) | i=1:size(A,1) ]
col_sums = [ sum(A[:,j]) | j=1:size(A,2) ]
\end{verbatim}

\subsection{Array Comprehensions of Non-Scalar Expressions}
If the computed expression of an array comprehension is not a scalar,
then all the values produced must be arrays of identical shape. The
dummy variable vectorization dimensions come before the expression
dimensions making the total dimension of the output array the number
of dummy variables plus the dimension of the inner expression. This
convention can be expressed by the following identity. If F is a
function mapping scalars to vectors, the following holds:
\begin{verbatim}
[ F(i) | i=ri ] == [ F(i)[j] | i=ri, j=rj ]
\end{verbatim}

\subsection{Examples}

\begin{itemize}
\item Diagonal of a matrix is computed as:
\begin{verbatim}
d = [ A[i,i] | i=1:min(dim(A)) ]
\end{verbatim}
\item Matrix product is computed as:
\begin{verbatim}
C = [ sum([ A[i,j].*B[j,k] | j ]) | i=1:size(A,1), k=1:size(B,2) ]
\end{verbatim}


\end{itemize}

\section{Strings}
\sec{strings}

% Traditionally, strings are conceptualized as sequences of characters, which mathematically is a function from indices to characters.
% When all characters are exactly one byte, this can be conveniently and efficiently represented with a plain old array of bytes.
% It's simple and efficient.
% End of story.
% 
% Unicode complicates things because common encodings like UTF-8 and UTF-16 are variable-width, meaning that characters require different numbers of bytes in their representation.
% In UTF-8, for example, all of the ASCII characters are one byte, encoded just as in ASCII.
% All other characters, however, take between two and four bytes to represent.
% This means that you can't efficiently look up the $k$th character of a string by doing array indexing anymore:
% the $k$th byte of the representation is no longer the $k$th character.
% Worse still, a byte might not be the beginning of a character at all, but right in the middle of a character (this is called a ``continuation byte'').
% 
% If you allow people direct access to the bytes of an encoded string, they can and will do all sorts of bad things that produce invalid Unicode and broken behaviors when Unicode input is received.
% To provide a string abstraction that makes strings behave like functions from indices to Unicode characters (i.e. code points), you have to chose one of the following:
% \begin{enumerate}
% 
% \item Have fast, natural random access to characters, but store strings so that every character is big enough to accommodate the entire Unicode character set.
% The natural choice of encoding for this is UTF-32, in which each code point (integer value representing a unique character) is simply represented by its 32-bit integer value.
% This also requires processing every string before accessing or manipulating it to convert it from its input encoding (usually UTF-8) to UTF-32.
% Transcoding introduces a lot of overhead, forcing every string to be transcoded, typically both on input and output, as well as inflating memory usage for all strings.
% 
% \item Sacrifice the ability to represent every Unicode character and use only the two-byte characters of a 16-bit encoding like UTF-16.
% With this you can represent virtually all modern languages, but you cannot write in ancient languages like Egyptian hieroglyphs, Linear B, or represent some unusual modern characters such as certain unified Han ideographs.
% This allows fast random access, and reduces the memory inflation compared to the UTF-32 approach, but still requires transcoding almost every string on input and output.
% 
% \item Keep strings in their input form, but make indexing into a string an $\O(k)$ operation which requires scanning the entire string from the beginning to find the $k$th character from there.
% This turns a lot of straightforward $\O(n)$ string processing algorithms into $\O(n^2)$ algorithms unless you completely avoid indexing into strings altogether.
% 
% \item Represent strings by a clever, relatively complex data structure that allows strings to remain encoded, but somehow makes indexing the $k$th character look like it's faster than $\O(k)$, when it is amortized over many operations.
% One possible way to do this is to remember the last few indices that were accessed and figure out new indices relative to them.
% 
% \item Do not allow indexing into strings. Instead, only provide interfaces, such as iterating characters, which are Unicode safe as well as being efficiently implementable without transcoding strings.
% 
% \item Ignore the whole issue and just equate strings with byte arrays and let Unicode bugger itself (a.k.a.~the C approach\footnote{To be fair, the C language long predates the Unicode standard.}).
% 
% \end{enumerate}
% Technically, option 5 doesn't actually keep the abstraction of strings as functions from indices to characters, so perhaps it doesn't belong here;
% and option 6 isn't a solution at all, but rather a matter of deciding that you just don't care.
% Option 2 is not really a solution, either, but a pragmatic compromise that gets you 90\% of the way (unless you happen to want to process hieroglyphs).
% Frankly, none of these options is good enough for something as fundamental and performance-critical as string processing.
% 
% \subsection{The Partial Function Approach}
% \sec{partial-function-strings}
% 
% Our approach is to change the abstraction of what a string is instead of choosing any of the above.
% Rather than conceptualizing a string as a function from indices to characters, we conceptualize a string as a \emph{partial function} from indices to characters.
% What does this mean?
% It means that when indexing into a string, for some indices no character value is returned:
% instead of returning a value, the language throws an exception.
% So in short \verb|str[k]| will throw an exception if $k$ doesn't correspond to a character.
% For UTF-8 strings that are plain ASCII this will never happen.
% For UTF-32 strings it will never happen.
% For UTF-16 strings including only the common two-byte characters it will never happen.
% For other instances of encoded strings, it could happen, however.
% 
% How does this modified abstraction help?
% It recognizes that bytes and characters are not one-to-one in many encodings, but still allows you store strings in their native encoding and retrieve characters efficiently by a byte index, rather than a character index.
% If you try to get or set a character at an index that isn't the start of a character, it's an exception---indicating that the partial function isn't defined there.
% The ``string''---as one normally thinks of it---is the sequence characters returned by the string as the indices range from one to the maximum index.
% The gotcha is that some indices don't return a character.
% 
% Code that na\"ively iterates through all indices will work and work with C-like performance, until it encounters strange input data, at which point it will throw a nice clean exception letting you know exactly what the problem is.
% You can probably just modify the code to catch the exception and move on to the next index.
% Alternately, you can rewrite the code to use a Unicode character iterator instead.
% Moreover, if you always consider string indices as opaque objects, and never do arithmetic with them (iterating through indices counts as arithmetic: \verb|k+=1|), then as long as you only index into a string with an index given to you by a string function, this kind of thing will never happen.
% 
% By changing the string abstraction, we can support arbitrary string encodings and other representations at C-like efficiency and with a nice, safe, clean programmatic interface.

There are a few noteworthy high-level features about Julia's approach to strings:
\begin{enumerate}
\item Like C, but unlike other dynamic languages, Julia has a first-class type representing a single character, called \verb|Char|.
A \verb|Char| is a special kind of 32-bit integer, whose numeric value represents a single Unicode code point.
\item Conceptually, a \verb|String| is a \emph{partial function} from indices to \verb|Char| values --- for some index values, no character values is returned, and instead an exception is thrown.
This for allows efficient indexing into strings by the byte index of an encoded representation rather than by character index, which cannot be implemented efficiently and simply in variable-width encodings.
\item There are many different classes implementing the \verb|String| interface, not a single special one.
They all implement a common programming interface, however, and any string type can be used in any function expecting a \verb|String|.
The predefined string types are no more special than user-defined ones.
\item Strings are immutable: the value of a \verb|String| object cannot be changed.
To construct a different string value, you construct a new string object.
\end{enumerate}

\subsection{Characters}

Like C, but unlike Perl, Python, or Ruby, Julia has a type for individual character values: \verb|Char|.
A \verb|Char| is really just a 32-bit integer with a special literal representation and some specific arithmetic behaviors.
Here is how \verb|Char| values are input and shown:
\begin{verbatim}
  julia> 'x'
  'x'

  julia> typeof(ans)
  Char
\end{verbatim}
You can convert a Char to its integer value (code point) easily:
\begin{verbatim}
  julia> int('x')
  120

  julia> typeof(ans)
  Int32
\end{verbatim}
You can convert an integer value back to a \verb|Char| just as easily:
\begin{verbatim}
  julia> char(120)
  'x'
\end{verbatim}
Not all possible integer values are valid Unicode code points, but for performance, the \verb|char| conversion does not check that the given character value is a valid Unicode code point.
If you want to check code points for validity, use the \verb|safe_char| conversion instead:
\begin{verbatim}
  julia> char(0xd800)
  '???'

  julia> safe_char(0xd800)
  invalid Unicode code point: U+d800

  julia> char(0x110000)
  '\U00110000'

  julia> safe_char(0x110000)
  invalid Unicode code point: U+110000
\end{verbatim}
As of this writing, the Unicode code points are \verb|U+0000| through \verb|U+d7ff| and \verb|U+e000| through \verb|U+10ffff|.
They are not all yet assigned intelligible meanings, nor are they necessarily interpretable by applications, but all such values are considered to be valid Unicode characters.

You can input any Unicode character in single quotes using \verb|\u| followed by up to four hexadecimal digits or \verb|\U| followed by up to eight hexadecimal digits (the longest valid value only requires six):
\begin{verbatim}
  julia> '\u0'
  '\0'

  julia> '\u78'
  'x'

  julia> '\u2200'
  '∀'

  julia> '\U10ffff'
  '\U0010ffff'
\end{verbatim}
Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the \verb|\u| or \verb|\U| forms.
In addition to these Unicode forms, all of the C language's input forms are usable as well, including literal plain ASCII characters:
\begin{verbatim}
  julia> int('\0')
  0

  julia> int('\t')
  9

  julia> int('\n')
  10

  julia> int('\e')
  27

  julia> int('@')
  64

  julia> int('\x7f')
  127

  julia> int('\177')
  127
\end{verbatim}
Like any integers, you can do arithmetic and comparisons with \verb|Char| values:
\begin{verbatim}
  julia> 'x' - 'a'
  23

  julia> 'A' < 'a'
  true

  julia> 'A' <= 'a' <= 'Z'
  false

  julia> 'A' <= 'X' <= 'Z'
  true
\end{verbatim}
Arithmetic with \verb|Char| values promotes them to \verb|Int32|, however, requiring explicit conversion back to \verb|Char|:
\begin{verbatim}
  julia> 'A' + 1
  66

  julia> char(ans)
  'B'
\end{verbatim}
The fact that any arithmetic with \verb|Char|s promotes to \verb|Int32| allows a series of intermediate computations to be done efficiently, only checking that the final value is a valid Unicode code point.

\subsection{String Basics}

Here is a basic string literal:
\begin{verbatim}
  julia> str = "Hello, world.\n"
  "Hello, world.\n"
\end{verbatim}
If you want to extract a character from a string, you index into it:
\begin{verbatim}
  julia> str[1]
  'H'

  julia> str[6]
  ','

  julia> str[end]
  '\n'

  julia> str[end-1]
  '.'
\end{verbatim}
Like all indexing in Julia, string indexing is 1-based, not 0-based.
Using an index less than 1 or more than \verb|end| raises an error:
\begin{verbatim}
  julia> str[0]
  in next: arrayref: index out of range

  julia> str[end+1]
  in next: arrayref: index out of range
\end{verbatim}
You can also a extract a substring using range indexing:
\begin{verbatim}
  julia> str[4:9]
  "lo, wo"
\end{verbatim}
Note the distinction between \verb|str[k]| and \verb|str[k:k]|:
\begin{verbatim}
  julia> str[6]
  ','

  julia> typeof(ans)
  Char

  julia> str[6:6]
  ","

  julia> typeof(ans)
  SubString
\end{verbatim}
The former is a single character value of type \verb|Char|, while the latter is a string value of type \verb|SubString| (we'll get into the nitty-gritty details later), having a string length of one.
These are very different things.

One of the most useful string operations is concatenation:
\begin{verbatim}
  julia> greet = "Hello"
  "Hello"

  julia> who = "world"
  "world"

  julia> strcat(greet, ", ", who, ".\n")
  "Hello, world.\n"
\end{verbatim}
As in Perl, you can interpolate values and expressions into strings using \verb|$|:
\begin{verbatim}
  julia> "$greet, $who.\n"
  "Hello, world.\n"
\end{verbatim}
This simpler and more readable, and completely equivalent to the above string concatenation---the system rewrites this apparent single string literal into a concatenation of string literals and values.
The shortest valid expression after an unescaped \verb|$| is used as the interpolated value:
\begin{verbatim}
  julia> "1 + 2 = $(1 + 2)"
  "1 + 2 = 3"
\end{verbatim}
Both concatenation and string interpolation call the \verb|string| function to convert objects into \verb|String| form.
Most non-\verb|String| objects are converted to strings the same way they are shown in the Julia repl:
\begin{verbatim}
  julia> v = [1,2,3]
  [1,2,3]

  julia> "vector: $v"
  "vector: [1,2,3]"
\end{verbatim}
\verb|String|s and \verb|Char|s are interpolated as themselves:
\begin{verbatim}
  julia> c = 'x'
  'x'

  julia> "hi, $c"
  "hi, x"
\end{verbatim}
Another useful string function is \verb|repeat|:
\begin{verbatim}
  julia> repeat(".:Z:.", 10)
  ".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."
\end{verbatim}
You can lexicographically compare strings using the standard comparison operators:
\begin{verbatim}
  julia> "abracadabra" < "xylophone"
  true

  julia> "abracadabra" == "xylophone"
  false

  julia> "Hello, world." != "Goodbye, world."
  true

  julia> "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
  true
\end{verbatim}
You can search for the index of a particular character using the \verb|strchr| function:
\begin{verbatim}
  julia> strchr("xylophone", 'x')
  1

  julia> strchr("xylophone", 'p')
  5

  julia> strchr("xylophone", 'z')
  char not found
\end{verbatim}
You can start the search for a character at a given offset by providing a third argument:
\begin{verbatim}
  julia> strchr("xylophone", 'o')
  4

  julia> strchr("xylophone", 'o', 5)
  7

  julia> strchr("xylophone", 'o', 8)
  char not found
\end{verbatim}
Some other useful functions include:
\begin{itemize}
\item \verb|length(str)| gives the maximal (byte) index that can be used to index into \verb|str|.

\item \verb|strlen(str)| the number of characters in \verb|str|.
This is \emph{not} the same as \verb|length(str)|, but we do always have the identity \verb|strlen(str)| $\le$ \verb|length(str)|.

\item \verb|i = start(str)| gives the first valid index at which a character can be found in \verb|str| (typically 1).

\item \verb|c, j = next(str,i)| returns next character at or after the index \verb|i| and the next valid character index following that.
With the \verb|start| and \verb|length|, can be used to iterate through the characters in \verb|str|.

% TODO: figure this out and fix it.

\item \verb|c, j = prev(str,i)| returns the character at or before index \verb|i| and the index at which it occurs.
With \verb|length| and \verb|start| can be used to iterate through the characters in \verb|str| in reverse.

\item \verb|ind2chr(str,i)| gives the number of characters in \verb|str| up to and including any at index \verb|i|.

\item \verb|chr2int(str,j)| gives the index at which the \verb|j|th character in \verb|str| occurs.
\end{itemize}

\subsection{String Internals}

What is the actual type and structure a string object?
\begin{verbatim}
  julia> dump("Hello, world.\n")
  Latin1String(data=[104,101,108,108,111,...,119,111,114,108,100],)
\end{verbatim}
Standard string literals like the above always produce either a \verb|Latin1String| or a \verb|UTF8String|.
Both of these types of strings are implemented using a byte array encoding \verb|Char| values.
\verb|Latin1String| uses a fixed-width, single-byte encoding, while \verb|UTF8String| uses the variable-width, UTF-8 encoding.

Here are the actual declarations of the basic string types from Julia's bootstrapping code:
\begin{verbatim}
  type String

  struct Latin1String <: String
      data::Array{Uint8,1}
  end

  struct UTF8String <: String
      data::Array{Uint8,1}
  end
\end{verbatim}
\verb|String| is an abstract supertype, which is used to refer to all concrete implementations of the string interface.
The \verb|Latin1String| and \verb|UTF8String| classes are both thin wrappers around an array of bytes (\verb|Uint8| values), holding the string's encoded data.
The only difference is in their interpretation:
\begin{enumerate}
\item In a \verb|Latin1String|, bytes and characters are one-to-one, and each byte encodes its Unicode code point directly, the way classic C strings do.
As you may have guessed, this encoding is called Latin-1.
\item In a \verb|UTF8String|, bytes and characters are not one-to-one, but instead uses the UTF-8 encoding, which matches ASCII and Latin-1 up to \verb|0x7f|, and uses two, three of four bytes to encode Unicode characters with higher code points.
\end{enumerate}
How does one generate a \verb|UTF8String| object?
One does so just by using a Unicode character escape sequence above \verb|0x7f| in a string literal:
\begin{verbatim}
  julia> "\u2200 x \u2203 y > x"
  "∀ x ∃ y > x"

  julia> dump(ans)
  UTF8String(data=[226,136,128,32,120,...,121,32,62,32,120],)
\end{verbatim}
Also, absent other indications, external text input is assumed to be encoded as UTF-8, and therefore creates \verb|UTF8String| objects.
String literals created in Julia without escapes, however, can be safely represented using Latin-1, which, being a fixed-width encoding, has much better performance characteristics than UTF-8.
In particular, \verb|Latin1String|s have zero decoding overhead because each character is represented directly by its byte value.
Therefore, Julia uses \verb|Latin1String|s internally whenever it can.

Because there are so many different ways a sequence of characters can be represented, Julia has many different string types, each with a different underlying implementation.
Also, programmers can easily define their own new string types.
The distinction between different string implementations is transparent to the casual observer in Julia.
You can perform string operations with all combinations of types of strings, and they will work:
all string functions are implemented generically in terms of a minimal core set of methods which any string must provide.

Generic implementations of string methods are often less efficient than optimal.
Julia's dispatch system fortunately makes it simple to provide specialized, fast methods in cases where the specific representation of a string can be leveraged somehow.
The typical user never needs to think about this:
just call the right generic function and the work will be dispatched to the appropriate method.
Consider, for example, comparing the lexicographic ordering of two strings:
\begin{verbatim}
  julia> "abracadabra" < "xylophone"
  true
\end{verbatim}
There is a generic string \verb|<| method which can compare any two strings, character by character, regardless of encoding or implementation.
In this case, however, both strings are \verb|Latin1String| objects, and a much faster method of comparison exists:
the \verb|libc| library's \verb|memcmp| function.
So a specialized \verb|<| method is provided to compare two \verb|Latin1String|s using this much faster method.
The usage is completely transparent, however:
regardless of what kinds of strings you have, you simply call \verb|a < b| to compare them.
If \verb|memcmp| can be used, it will be;
if not, the comparison will work, albeit not quite as quickly.
The same trick applies to comparing a pair of \verb|UTF8String|s:
UTF-8 is carefully designed to allow using \verb|memcmp|.

Allowing many different string representations to coexist and interoperate smoothly provides significant flexibility and power.
For example, Julia performs string concatenation using ropes:
\begin{verbatim}
  julia> strcat("foo","bar")
  "foobar"

  julia> dump(ans)
  RopeString(head="foo",tail="bar",depth=1,length=6,)
\end{verbatim}
This makes concatenation, which is by far one of the most common string operations, take $\O(1)$ time rather than $O(n)$ time, as it does if a new memory buffer must be allocated and both strings copied into it.
Another very useful operation is repeating a string:
\begin{verbatim}
  julia> zzz = repeat(".:Z:.", 100000);

  julia> strlen(zzz)
  500000

  julia> zzz[end>>1-15:end>>1+16]
  "..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.."
\end{verbatim}
In julia this requires very little memory because the repeat operation just creates a special kind of string:
\begin{verbatim}
  julia> dump(zzz)
  RepString(string=".:Z:.",repeat=100000,)
\end{verbatim}
The resulting object behaves as though you had a 5MB string in memory, but does so using mod operations when indexing rather than by actually allocating 5MB.
If you actually want to allocate all that memory, you can force Julia to do so by coercing the \verb|RepString| into a byte-backed ``C string'':
\begin{verbatim}
  julia> zzz = cstring(zzz);

  julia> typeof(zzz)
  Latin1String
\end{verbatim}

\section{I/O}
\section{Data Structures}
\subsection{Hash Tables}
\subsection{Sets}
\subsection{Queues and Dequeues}
\subsection{Trees}
\subsection{Lists}

\section{Parallel Computing}
\begin{itemize}
  \item \verb|Worker()| ---
     create a new local worker

  \item \verb|remote_apply(w, func, args...)| ---
     tell a worker to call a function on the given arguments.
     for now, functions are passed as symbols, e.g. \verb|:randn|
     returns a Future.

   \item \verb|wait(f)| ---
     wait for, then return the value represented by a Future

   \item \verb|pmap(pool, func, lst)| ---
     call a function on each element of \verb|lst| (some 1-d thing), in
     parallel. pool is a list of available Workers.

   \item \verb|send_msg(socket, x)| ---
     send a Julia object through a socket

   \item \verb|recv_msg(socket)| ---
     read the next Julia object from a socket
\end{itemize}

\section{Calling C Functions}
\section{Running External Programs}

% Perl, Python, and Ruby are well known for their ability to easily run and interact with other programs.
% In Perl and Ruby, backticks provide a powerful and simple way to call a program and capture its output as as a string:
% \begin{verbatim}
%   #!/usr/bin/env perl
%   $greeting = `echo -n hello`;
%   print "$greeting, world.\n";
% \end{verbatim}
% In this rather simplistic example, the \verb|echo| program prints the string \verb|"hello"| and that output is captured into the variable \verb|$greeting|.
% Arbitrary shell commands can be spawned in backticks because backticks actually spawn a shell to interpret and run these commands.
% Thus, much of the power of this approach comes from the shell---the programming language just spawns the shell and arranges to capture the output.
% You can pass data to the programs spawned by interpolating values into the shell command:
% \begin{verbatim}
%   #!/usr/bin/env perl
%   $sorted = `sort -n $file`;
% \end{verbatim}
% Here things become a bit dangerous:
% if the value of the variable \verb|$file| contains characters that are specially interpreted by the shell, they will be.
% For example, if \verb|$file| is the string \verb|"/Volumes/External HD/data.csv"|, then the above command will attempt to sort the contents of two files named \verb|/Volumes/External| and \verb|HD/data.csv|, which are likely to either not exist, or possibly worse, not be the intended files.
% 
% There are two approaches one can take to address this issue: escape all the shell metacharacters in the the string \verb|$file| before interpolating it, or avoid using the shell by calling a lower level function like \verb|exec|.
% Both Perl and Ruby provide some ability to start a program and then read from its output file descriptor, but these approaches rapidly become quite cumbersome.
% Shell metacharacter escaping is provided by some third party modules, but is not a standard part of the installation of any of the scripting languages, and is hard to get right:
% the shell itself has a lot of complexity and syntax.
% In practice, programmers calling external programs simply tend to just hope that there are no strange characters in their file names.
% A few of the more paranoid will wrap arguments in single quotes within the backticks, writing \verb|`sort -n '$file'`|.
% This, however, is quite ugly, annoying, and worst of all, doesn't actually fix the problem.
% 
% Julia takes the second approach:
% instead of calling a shell to spawn external commands, Julia performs all the tricky UNIX pipe plumbing for you.
% Moreover, it allows you to easily create pipelines \emph{in Julia} where one command pipes output to another.
% In essence, Julia aims to be a better shell than the shell.

Julia borrows backtick notation for commands from shells, Perl, and Ruby.
However, in Julia, writing
\begin{verbatim}
  julia> `echo hello`
  `echo hello`
\end{verbatim}
differs in a several aspects from the behavior in shells, Perl, or Ruby:
\begin{itemize}

\item Instead of immediately running the command, backticks create a \verb|Cmd| object to represent the command.
You can use this \verb|Cmd| object to connect this command to others via UNIX pipes, run it, write to it and read from it.

\item When the command is run, Julia doesn't capture its output unless you specifically arrange for it to.
Rather, the output of the command by default goes to \verb|stdout| as it would using \verb|libc|'s \verb|system| call.

\item The command is never run with a shell.
Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax.
The command is run as \verb|julia|'s immediate child process, using \verb|fork| and \verb|exec| calls.

\end{itemize}
Here's a simple example of actually running an external program:
\begin{verbatim}
  julia> run(`echo hello`)
  hello
  true
\end{verbatim}
The \verb|hello| is the output of the \verb|echo| command, while the \verb|true| is the return value of the command, indicating that it succeeded.
(These are colored differently by the repl if your terminal supports color.)

\subsection{Interpolation}

Suppose you want to do something a bit more complicated and use the name of a file in the variable \verb|file| as an argument to a command.
You can use \verb|$| for interpolation much as you would in a string literal:
\begin{verbatim}
  julia> file = "/etc/passwd"
  "/etc/passwd"

  julia> `sort $file`
  `sort /etc/passwd`
\end{verbatim}
A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior.
Suppose, for example, rather than \verb|/etc/passwd|, we wanted to sort the contents of the file \verb|/Volumes/External HD/data.csv|.
Let's try it:
\begin{verbatim}
  julia> file = "/Volumes/External HD/data.csv"
  "/Volumes/External HD/data.csv"

  julia> `sort -n $file`
  `sort -n '/Volumes/External HD/data.csv'`
\end{verbatim}
Julia knows that \verb|file| is supposed to interpolated as a whole word, so it quotes the argument as necessary.\footnote{This is a bit inaccurate:
the value of \texttt{file} is never interpreted by a shell, so there's no need for actual quoting.
The quotes are inserted only for presentation to the user such that you can cut and paste it back into the repl.}
This will even work if you interpolate a value as just part of a shell word:
\begin{verbatim}
  julia> path = "/Volumes/External HD"
  "/Volumes/External HD"

  julia> name = "data"
  "data"

  julia> ext = "csv"
  "csv"

  julia> `sort $path/$name.$ext`
  `sort '/Volumes/External HD/data.csv'`
\end{verbatim}
But what if you \emph{want} to interpolate multiple words?
Just use an array (or any other iterable container):
\begin{verbatim}
  julia> files = ["/etc/passwd","/Volumes/External HD/data.csv"]
  ["/etc/passwd","/Volumes/External HD/data.csv"]

  julia> `grep foo $files`
  `grep foo /etc/passwd '/Volumes/External HD/data.csv'`
\end{verbatim}
If you interpolate an array as part of a shell word, Julia emulates the shell \verb|{a,b,c}| shell generation behavior:
\begin{verbatim}
  julia> names = ["foo","bar","baz"]
  ["foo","bar","baz"]

  julia> `grep xylophone $names.txt`
  `grep xylophone foo.txt bar.txt baz.txt`
\end{verbatim}
If you interpolate multiple arrays, the shell's Cartesian product generation behavior is emulated:
\begin{verbatim}
  julia> names = ["foo","bar","baz"]
  ["foo","bar","baz"]

  julia> exts = ["aux","log"]
  ["aux","log"]

  julia> `rm -f $names.$exts`
  `rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{verbatim}

\subsection{Quoting}

Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes.
Here's a typical example of a perl one-liner at shell prompt:
\begin{verbatim}
  $ perl -le '$|=1; for (0..3) { print }'
  0
  1
  2
  3
\end{verbatim}
One wants to use single quotes around the Perl expression for two reasons:
so that spaces don't break it into multiple shell words, and uses of variables like \texttt{\$|} (yes, that's a variable), don't cause shell interpolation.
In other instances, you want to use double quotes so that interpolation does occur:
\begin{verbatim}
  $ first="A"
  $ second="B"
  $ perl -le '$|=1; print for @ARGV' "1: $first" "2: $second"
  1: A
  2: B
\end{verbatim}
The Julia backtick syntax is specifically designed so that you can simply cut-and-paste shell commands as-is directly into it and they will work.
Let's try the above two examples:
\begin{verbatim}
  julia> `perl -le '$|=1; for (0..3) { print }'`
  `perl -le '$|=1; for (0..3) { print }'`

  julia> run(ans)
  0
  1
  2
  3
  true

  julia> first = "A"
  "A"

  julia> second = "B"
  "B"

  julia> `perl -le 'print for @ARGV' "1: $first" "2: $second"`
  `perl -le 'print for @ARGV' '1: A' '2: B'`

  julia> run(ans)
  1: A
  2: B
  true
\end{verbatim}
In short, quoting of words, interpolation, and escaping inside of Julia's backticks all behave exactly the same way as they do in a shell.
When in doubt, cut and paste.
Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation before doing anything.

\subsection{Pipelines}

One thing that does not work inside of Julia's backticks like it does in the shell are metacharacters like \texttt{|}, \verb|&|, and \verb|>|.
Unlike in the shell, inside of Julia's backticks, a pipe is always just a pipe:
\begin{verbatim}
  julia> run(`echo hello | sort`)
  hello | sort
  true
\end{verbatim}
This command prints the word ``hello'' followed by a literal pipe character followed by the word ``sort.''
Then how does one construct a pipeline?
Use Julia's \texttt{|} operator on \verb|Cmd| objects instead:
\begin{verbatim}
  julia> run(`echo hello` | `sort`)
  hello
  true
\end{verbatim}
This pipes the output of the \verb|echo| command to the \verb|sort| command.
Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:
\begin{verbatim}
  julia> run(`cut -d: -f3 /etc/passwd` | `sort -n` | `tail -n5`)
  210
  211
  212
  213
  214
  true
\end{verbatim}
This prints the highest five user IDs on a UNIX system.

\newpage
is retained, but in Julia it doesn't run the command immediately, but rather creates a \verb|Cmd| object:
\begin{verbatim}
  julia> cmd = `echo hello`
  `echo hello`

  julia> dump(cmd)
  Cmd(exec=("echo",("hello",)),
      pipes=HashTable(),pipeline=Set([`echo hello`]),
      pid=0,status=ProcessNotRun(),)
\end{verbatim}
The \verb|Cmd| object is a structure encoding what command to run as well as metadata about the resulting process and other related commands.
For convenience, however, it is shown in the input format.
The immediately obvious thing to do with a \verb|Cmd| object is to run it:
\begin{verbatim}
  julia> run(cmd)
  hello
  true
\end{verbatim}
The \verb|hello| part above is the output from the echo command, while the \verb|true| part is the value retuned by the \verb|run| function, indicating that all the subprocesses spawned by \verb|run| succeeded.
Here we see one advantage of spawning processes directly:
the program has access to the status of each spawned child program, thereby avoiding not only the overhead of starting a shell, but also the potential it causes for hiding programming errors.
Metadata about the completed process is retained in the \verb|cmd| object after the process completes:
\begin{verbatim}
  julia> dump(cmd)
  Cmd(exec=("echo",("hello",)),
      pipes=HashTable(),pipeline=Set([`echo hello`]),
      pid=79300,status=ProcessExited(0),)
\end{verbatim}

If you want to pass data to a program as an argument, it looks very similar to the previous example in Perl:
\begin{verbatim}
  julia> file = "/Volumes/External HD/data.csv"
  "/Volumes/External HD/data.csv"

  julia> `sort -n $file`
  `sort -n '/Volumes/External HD/data.csv'`
\end{verbatim}
Wait? How did the file argument get quoted?
The Julia backtick syntax understands both shell argument quoting \emph{and} how the arguments are interpolated.
It knows that \verb|$file| is supposed to be a single argument and correctly generates arguments to an \verb|exec| call that safely do what you intended.
When showing the \verb|Cmd| object, the output is generated so that if evaluated, it creates an equivalent command object.

The fact that the backtick syntax is intelligently integrated with the language is quite powerful.
Arrays are interpolated correctly as multiple arguments:
\begin{verbatim}
  julia> files = {
           "/Volumes/External HD/data.csv"
           "tmp/other.csv"
         }
  {"/Volumes/External HD/data.csv","tmp/other.csv"}

  julia> `sort -n $files`
  `sort -n '/Volumes/External HD/data.csv' tmp/other.csv`
\end{verbatim}
Note that this is interpolated correctly as two arguments, the first containing a space, rather than incorrectly as three arguments as it would in Perl or Ruby.
If a collection is interpolated as part of a larger command argument, Julia emulates the shell \verb|{a,b,c}| argument generation syntax:
\begin{verbatim}
  julia> names = {"foo","bar","baz"}
  {"foo","bar","baz"}

  julia> `rm -f $names.txt`
  `rm -f foo.txt bar.txt baz.txt`
\end{verbatim}
If multiple collections are interpolated into a single argument, it produces the cartesian product of their concatenations, again emulating the behavior of the shell's \verb|{a,b,c}| syntax:
\begin{verbatim}
  julia> exts = {"aux","log"}
  {"aux","log"}

  julia> `rm -f $names.$exts`
  `rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{verbatim}

Especially when calling other programming languages, it may become necessary to use spaces, escapes, or quotes.
In these matters, Julia emulates the shell:
it respects shell-style semantics for spaces, escapes, quoting, and interpolation.
In particular, variable interpolation does not occur inside of single quotes:
\begin{verbatim}
  julia> a = 9; b = 1; c = "hello";

  julia> `perl -le 'print "'$a'"; print $_ for @ARGV' $b "c: $c"`
  `perl -le 'print "9"; print $_ for @ARGV' 1 'c: hello'`

  julia> run(ans)
  9
  1
  c: hello
  true
\end{verbatim}
Here a Perl program is provided via the \verb|-e| option and is protected from interpolation by single quotes.
The \verb|$a| is interpolated, however, because the single quotes are closed and opened again;
the \verb|$_| is not interpolated because it is still protected by single quotes;
the \verb|$b| is a bare argument, and is thus interpolated, and the \verb|$c| is interpolated as part of an argument because double quotes do not prevent interpolation.
This may seem quite complex, but it is carefully designed so that you can basically just cut and paste commands from the shell and expect backticks to do the right thing, safely and correctly.

Unlike the shell, besides escapes, quotes, and spaces, no other characters are treated specially---a pipe is always just a pipe:
\begin{verbatim}
  julia> run(`echo | sort`)
  | sort
  true
\end{verbatim}
This just prints a literal pipe character and the word ``sort.''
Other shell meta-characters, like \verb|!| and \verb|&| are similarly interpreted literally.
For complex shell-like programming, you use Julia's operators to manipulate \verb|Cmd| objects instead:
\begin{verbatim}
  julia> run(`cut -d: -f3 /etc/passwd` |
             `perl -nle 'print unless /^\s*#/'` |
             `sort -n` | `head`)
  -2
  0
  1
  4
  26
  27
  54
  55
  56
  58
  true
\end{verbatim}
It's simple to run multiple programs in parallel and wait for them all to finish:
\begin{verbatim}
  julia> run(`echo hello` & `echo world`)
  world
  hello
  true
\end{verbatim}
The order of the output here is non-deterministic because the two \verb|echo| processes are started nearly simultaneously, and race make the first write to the \verb|stdout| descriptor they share with each other and with their parent \verb|julia| process.
Julia lets you pipe the output from these parallel processes to another program easily:
\begin{verbatim}
  julia> run(`echo world` & `echo hello` | `sort`)
  hello
  world
  true
\end{verbatim}
That's something you cannot do in the shell, and while you can do it in Perl, Python, or Ruby, it requires unpleasant and tricky mucking around with the \verb|pipe|, \verb|dup2|, \verb|fork|, and \verb|exec| system calls.

Now we're just going to showboat a bit (apologies for excessive Perlage):
\begin{verbatim}
  julia> prefixer(sleep, prefix) =
           `perl -nle '$|=1;
                       print "'$prefix' ", $_;
                       sleep '$sleep';'`
  Methods for generic function prefixer
  prefixer(Any,Any)

  julia> run(`perl -le '$|=1; for(0..9){ print; sleep 1 }'` |
             prefixer(2,"A") & prefixer(2,"B"))
  A	0
  B	1
  A	2
  B	3
  A	4
  B	5
  A	6
  B	7
  A	8
  B	9
  true

  julia> run(`perl -le '$|=1; for(0..9){ print; sleep 1 }'` |
             prefixer(3,"X") & prefixer(3,"Y") & prefixer(3,"Z") |
             prefixer(2,"A") & prefixer(2,"B"))
  B	Y	0
  A	Z	1
  B	X	2
  A	Y	3
  B	Z	4
  A	X	5
  B	Y	6
  A	Z	7
  B	X	8
  A	Y	9
  true

  julia> gen = `perl -le '$|=1; for(0..9){ print; sleep 1 }'`
  `perl -le '$|=1; for(0..9){ print; sleep 1 }'`

  julia> dup = `perl -ne '$|=1; warn $_; print ".$_"; sleep 1'`
  `perl -ne '$|=1; warn $_; print ".$_"; sleep 1'`

  julia> run(gen | dup | dup)
  0
  .0
  1
  ..0
  2
  .1
  3
  ...0
  4
  .2
  5
  ..1
  6
  .3
  ....0
  7
  .4
  8
  9
  ..2
  .5
  ...1
  .6
  ..3
  .....0
  .7
  ..4
  .8
  .9
  ...2
  ..5
  ....1
  ..6
  ...3
\end{verbatim}
The final example never terminates since the \verb|dup| process reads its own output and duplicates it to \verb|stderr| forever.
We strongly encourage you to try all these examples to see how they work.

\section{Standard Library Reference}

\section{Macros}

Macros are totally different from inlining.
Macros are a hook into the compiler that lets you examine and rewrite the syntax of a piece of the program.
You can use them to implement entirely new syntactic constructs like remote spawn, parallel for loops, string interpolation, pattern matching, Julia's command syntax, etc.

Macros also run at an earlier binding time than functions and so have different semantics.
Inlining moves code around in a way that keeps the same function call semantics, i.e. you can't ``tell'' that it happened.
Macros are just the opposite.
For example, say I have a function that contains an inner function:

\begin{verbatim}
  function foo()
    bar(x) = XXX
    ...
    bar(...)
  end
\end{verbatim}

Now I want to abstract away the definition of \verb|bar|.
Maybe I want to use it in multiple functions and I don't want to copy and paste it.
With macros I can do this:

\begin{verbatim}
  macro definestuff(name)
    quote
      ($name)(x) = XXX
    end
  end

  function foo()
    @definestuff bar
    ...
  end
\end{verbatim}

This is not possible without macros.
If you passed \verb|:bar| to a function, that function has no way to define a local \verb|bar| inside \verb|foo|.
If it used \verb|eval|, it would define a top-level function called \verb|bar|. 
Since the macro runs so much earlier, it can change the code of \verb|foo| itself, so it can easily modify local variables.

And this example hardly shows the full power, since the argument to
the macro is only a symbol.
This is just to show the semantic differences.
Another example is \verb|spawn|:

\begin{verbatim}
  macro spawn(expr)
    quote
      spawn(()->($expr))
    end
  end
\end{verbatim}

Now you can write \verb|@spawn a+b| and it will call a function \verb|spawn| on \verb|a+b| wrapped in a thunk.
This syntax improvement requires macros:
the function call \verb|spawn(a+b)| couldn't work since \verb|a+b| will be fully evaluated before \verb|spawn| is called.
Calling a quoted expression, as in \verb|spawn(:(a+b))|, is ugly and moreover simply wouldn't work since \verb|spawn| cannot use the expression \verb|:(a+b)| by itself to access the values of local variables \verb|a| and \verb|b|.

People often compare macros to inlining (for example, the designer(s) of C++), but this is a pun.
There is only a superficial similarity of inserting code into other code.

\section{Command-Line Options}
\sec{command-line-options}

\begin{verbatim}
  julia [options] [program] [args...]
   -q --quiet               Quiet startup without banner
   -R --no-readline         Disable readline functionality
   -e --eval=<expr>         Evaluate <expr> and don't print
   -E --print=<expr>        Evaluate and print <expr>
   -P --post-boot=<expr>    Evaluate <expr> right after boot
   -H --home=<dir>          Load files relative to <dir>
   -T --tab=<size>          Set REPL tab width to <size>
   -L --lisp                Start with Lisp prompt not Julia
   -b --bare                Bare REPL: don't load start.j
   -h --help                Print this message
\end{verbatim}

\end{document}
