* some kind of macros as an alternative to auto conversion
* convert when assigning to typed locations
- architecture of real implementation
-------------------------------------------------------------------------------

fixes
* fix method cache bug
* fix ctranspose
* provide default unique generic type parameters if none given
* for conversions, make generic parameters present in destination type
  available in the function body
* only skip generic matching if an existing method matches exactly
- update wiki
* allow partial type application; fill in missing with dummy typevars
* add NTuple
-------------------------------------------------------------------------------

features
* f(x) = x syntax
* write up module design ideas
* switch open type parameters to TypeVars
- next_method
- common_supertype
- improve the situation with numeric literals somehow

- where clauses
? allow chains of conversions
? extend search space used by (conform )
  . conform (Rational[Int32],Float64) (Complex[`T],Complex[`T])
? coerce()
-------------------------------------------------------------------------------

speculation
* i wish we could write an elementwise() macro to generate operators
- complex number syntax?
* declaring abstract types
- a type with plain-old-data fields can be treated as a value type if it
  is immutable. a mutable value type is just a thing that's allowed to behave
  confusingly. the immutability is key, "value type" is an optimization
  the user doesn't have to worry about.
  to handle immutable-element-in-mutable-container, we need a special meaning
  for "a[i].re = x". it means a[i] = complex(x, a[i].im)...
  most plausible implementation is to translate it to
  a[i] = setfield(a[i], 're, x)
  and have setfield copy value types

- recursive types (tree.j) are too verbose. we should be able to say something
  like:
  type EmptyTree = ()
  type Tree[`T] = Union[EmptyTree, (data=T,left=Tree[T],right=Tree[T])]

syntax idea:

typeunion Tree[T]
  struct EmptyTree
  end

  struct TreeNode[T]
    data::T
    left::Tree[T]
    right::Tree[T]
  end
end

Much better way to do recursive types without fiddly syntax!!
Means the exact same thing as what we have now in tree.j with Union(),
except permits the required nesting!

- maybe make everything invariant, use where-clauses instead
  where-clauses create a constraint environment, sufficient to
  express "field types". For example
  Array[dims, data] where dims<:Buffer[Size], data<:Buffer

- implicit constructors instead of needing to define boilerplate functions
  like complex() and rational()
* explicit different kinds of types. e.g. StructType, NumericType
  . conceptually helpful, because you can only use new(T,...) on struct types.
    new(Int8) doesn't work, and new(Symbol) doesn't work...
- use {} for type parameters, e.g. Complex{Float64}

- idea: only allow field access (dot) on variables whose type is statically
  known. this (1) guarantees that field access is fast, and (2) allows us
  to prevent field access on types not visible (exported) to the current
  module. Example

module A
export Public
struct Public
  field::Private
end
struct Private
  a
  b
end
end

module B
import A.Public
x = Public.new()  # ok
x.field           # ok
x.field.a         # not allowed
end

Another way to see this is: does it makes sense to write "f(x) = x.a"? In
other words field access is not a generic operation. We have 3 kinds of
operations:
static: like add_int32, requires specific statically-known types
function: like the functions is() and istype(), works on any type or almost
          any type, but may not have new definitions added.
generic function: the most general kind of function. supports dispatch.

the question is, which kind of operation is field access?
currently it is kind #2.

- want some way to define types that are variants of others, for example
  matrices with named rows and columns, without lots of redundant work.

-------------------------------------------------------------------------------

a perpetual question is "where do objects come from?"
there are two views: user-defined constructors (C++,java,etc.), and builtin
functions (C,scheme,matlab,etc.)

constructor view:
. there is a hook to run code every time a type is instantiated
. you can have uninitialized instances
. the "actual" allocation routine is hidden, and the special form "new" is
  used. "new T()" means roughly
    x = magic_allocate<T>()
    call T's constructor with this==x
    return x
. constructor is "inside" the type, so type parameters naturally and easily
  parameterize the constructor as well.

function view:
. the magic_allocate function is exposed, anybody can make any object
. our new(T,...) forces you to provide values of correct types for all
  fields, eliminating null references ("RAII")
. consistent with our design of not encapsulating functions with types
. BUT no way to enforce invariants other than field types. for example
  you can make an Array where the dims is the wrong length!

C++-style constructor is actually an initializer; it doesn't return a value.

if we have constructors that return values, they might return nonsense.

if not, we need special syntax like new, and to magically deliver the
actual object to the constructor. but how to enforce that it gets
initialized? do we require DFA to show that all fields are set and none
are accessed before being set? this constrains the programming style.

IDEA: have a special new() function in scope for user-defined constructors
inside the type definition:

struct Foo
    ...

    function Foo(any, arguments, x)
        return new(any-x, x*any)
    end
end

new() is the only way to make objects. it's a sealed generic
function that only accepts arguments of the field types, and it's only
visible inside the struct definition, so you can guarantee that immutable
objects obey your invariants. Then calling Foo() externally calls
your constructors. You can define new Foo() methods externally, but they
can't see new() so they have to call other Foo constructors. You get full
flexibility plus an abstraction barrier. If you don't write any constructors
you get the default, Foo(args...) = new(args...).

-------------------------------------------------------------------------------

conversion/dispatch test cases:

1+rational(1,2)
rational(1,2)+0.5
1./complex(2.,2.)
1/complex(2.,2.)

-------------------------------------------------------------------------------

notes from "Using category theory to design implicit conversions and
generic operators"

conversions must commute:
OP(convert(x,T),convert(y,T)) == convert(OP(x,y),T)
if A->B and B->C, then A->C must be the composition of these two conversions

define operators for "key sorts", like (int,int) (real,real) and let
conversions handle the rest (this was our idea too!)

"one can never use the same operator for the equality relation on different
data types when the data types are connected by an implicit conversion
function which is not an injection"

-------------------------------------------------------------------------------

functions needed to port colorimetry library:

construct matrix,vector from scalars
persistent constant matrices
1d,2d scalar indexing
2d indexing with colon
elementwise mat,vec ops
matrix multiply
dot product
min,max
transpose
1d comprehension
-------------------------------------------------------------------------------

invariance vs. covariance

what does Array[Number] mean in various contexts?

new(Array[Number,n],...)
make an array that can hold various kinds of numbers, but only numbers

as a typed location, e.g. "local x::Array[Number]"
doesn't really matter. both the user & compiler don't know exactly
what kind of numbers will come out of there. user doesn't care whether
it is actually an Array[Float64], etc., but compiler does.

matching argument types, foo(x::Array[Number])
would you want to write a function just for arrays created with element
type number? sometimes a function works differently on cell arrays vs.
numeric arrays. do you need to ensure that foo(x::Array[Any]) is only
called on an actual cell array, or would it be ok to substitute any
sort of array?

with invariance, you can express this. only actual cell arrays will match.
otherwise you can write Array[T <: Any], Array[T <: Number], etc.
under covariance, the compiler effectively treats Array[Any] as Array[T]
because it needs to specialize it anyway.

-------------------------------------------------------------------------------

paper/thesis ideas:

design recommendations for technical computing languages

the design and implementation of julia

reinventing the repl: language support for interactive use

improving numeric type systems, e.g. apprach to type promotion

a highly unobtrusive type system

eliminating array allocations in loops
or using register allocation to manage general resources
or inference for minimizing temporary space use. e.g. figure out
  that in-place matmul can be done with O(n) space overhead.

performance survey over the course of a language implementation (with llvm)

destination-passing (generalized nargout), allowing discovery of some
  aspects of the continuation to get some of the benefits of lazy
  evaluation or for space optimization.

-------------------------------------------------------------------------------

function representation
-----------------------

new functions are created in many ways:
- new (empty) generic function
- copy closure
- adding a template method to a generic function
  . any function can have static parameters, but automatic
    instantiation based on argument types is done by generic functions
- creating a new specialization inside a generic function.
  . type-specific (non-template) method is added manually by the user,
    compiled on first call
  . a more general method matches, compile for new types
  . a template method matches; apply static lambda and compile
  . *** We need a way to create the generic function and cache all
    generated code for an inner function only once, but still be able to
    add new closure environments.

  important optimization: sharing generated code for generic inner functions
  . must lift generic function creation to the top level, then when
    we enter the enclosing function, shallow copy the GF and replace
    all the closure environments with new ones. hard case is when an
    inner function has multiple definitions, each one needs a different
    closure environment. or we could combine all definitions for
    inner functions into a single one (since we can see the full set of
    definitions statically), and have a special inner-generic-function
    that can share an entire method table. on each call to the encl.
    function we just make a new IGF object with a new cloenv, and the IGF
    passes this cloenv onto any method that's actually invoked.

  . for now we will just have to make a new GF on each call to the enclosing
    function

closure ::=
    <
    type tag - a function type
    code pointer
    closure data
    static data
    >

new_closure copies this, with new closure data field

static data ::=
    <
    name
    AST
    static parameter env
    >


a GF looks like <Any-->Any, apply_generic, (methtable,), ()>

in the "let over lambda" case, a top-level GF method might have a closure
environment.

(lambda args (var-info (locals ...) vinfo-list capt-list static-params)
             #(body statements))

so in the interpreter the static parameters are inside the AST, but no
big deal.

-------------------------------------------------------------------------------

issues 5/31/10

- covariance
  . we will use T{S<:R} type patterns instead of covariance.
  . T{S} is covariant iff T is abstract.

- unions, tagged unions
  consider Cons(Cons(`a,nil), Cons(nil, nil)), or {{a}, {}}
  the type of {{}} is inferred as Cons{EmptyList}, then we have
  Cons{Cons{Symbol}}. these need to match. if we picked
  T == List{Symbol} == Union(EmptyList,Cons{Symbol}), it would have worked.
  Should there be both Cons{Cons{Symbol}} and Cons{List{Symbol}} ?
  . the way it would work is during matching, T starts as Cons{EmptyList}.
    when we try to add T==Cons{Cons{Symbol}}, we see EmptyList and Cons
    are disjoint, but they explicitly indicate a common supertype List,
    so we can pick that. type_match will only pick values of T from the
    types actually present, or their typeunion parents.

- inferred type parameters. problem with union types, e.g.
  struct Foo{T,S}
    a::Nullable{T}
    b::Nullable{S}
  end

  what is the type of Foo((),()) ?
  Should we give it unconstrained type variables, then adjust their bounds
  when the object is mutated?
  It would be great to get rid of T{...}.new(...) altogether.
  . idea is to use Nullable{T}==Union(T,Null{T}), but currently that Union
    type is too complex!

* in f{T}(T, T) allow the actual types to differ as long as one is a
  supertype of the other. for example, taking the type intersection of
  (Real, Int) with (T, T) should give (T<:Int, T<:Int)

* in matching_methods, don't include signature S if we've already found
  a signature R such that T <: R <: S, where T is the type we're searching for

* given f(Int32, Int32), matching f(T, T) and giving it priority over
  f(Int, Int) is wrong. typevars should be treated like types, and all
  methods must be consistently comparable with each other for specificity.
  . monotonicity: if the declaration of A is more specific than B,
    it remains that way for all possible actual arguments.

* need to make Type <: Function
  plus SomeType{T}(args...) should work, no .new
  make structs with no fields singletons
  so both Complex and Complex{...} should be types, and also applicable

plan:
* TypeConstructor only for typealias
* typename->ctor becomes typename->primary, and points to the original
  version of a type
* Complex, e.g., is a StructType. both Function and StructType are applicable
  . this avoids the issue of abstract types being functions, which is crazy
* T{...} can work on either TypeConstructor or a TagType
* when applying a type or typector to concrete types, enforce that all typevar
  bounds are respected.
* start off every struct type as a constructor-factory-trampoline function,
  so no constructors are created until constructing is actually attempted.
* add the ability to seal a generic function. use for constructors.
. keep track of whether a method is "generic" explicitly, instead of
  using jl_has_typevars. when matching, make sure the method's own static
  parameters were what matched, e.g.
  foo{T,S}(a::SomeType, b::OtherType)
  typevars in SomeType and OtherType might match, but we could not infer T,S
  so this is an error. this fully generalizes the "cannot infer type
  parameters from arguments" error in generic constructors, so it would not
  be needed there any more.
. consider changing the rules so in f(x::T...) T is the union of the actual
  argument types.

* add the ability to hide the default constructor, which also makes it
  possible to add multiple constructor overloads:

struct Rational <: Real
    num::Int
    den::Int

    #implicit: new(x::Int, y::Int) = construct(Rational, x, y)

    Rational(n::Int, d::Int) = new(lowest_terms(n,d)...)
    Rational(n::Int) = Rational(n, 1)
end

or if no constructor defs are present:
   add_generic_constructor(Rational), which does
   Rational(x::Int, y::Int) = construct(Rational, x, y)

struct Rational{T<:Int} <: Real
    num::T
    den::T

    #implicit: new{T<:Int}(x::T, y::T) = construct(Rational{T}, x, y)

    new::((T,T)-->Rational{T})
    Rational(n::Int, d::Int) = new(lowest_terms(n,d)...)
    Rational(n::Int) = Rational(n, 1)
end

   add_generic_constructor(Rational) does
   Rational{T<:Int}(x::T, y::T) = construct(Rational{T}, x, y)

now what does e.g. Rational{Int8} mean?
technically we should repeat the whole declaration with this substitution
done:
struct Rational{Int8} <: Real
    num::Int8
    den::Int8

    #implicit: new(x::Int8, y::Int8) = construct(Rational{Int8}, x, y)

    Rational(n::Int, d::Int) = new(lowest_terms(n,d)...)
    Rational(n::Int) = Rational(n, 1)
end

the key is to keep the closure that defines the constructors:

constructor_defining_closure(Rational, new) = begin
   ... all user's constructor decls go here ...
end

initially we call constructor_defining_closure(Rational, new)

when we instantiate a type, e.g. Rational{Int8}, we make a new type
object that's also an empty generic function (no methods).
then we make "new", the base constructor for it.
R = instantiate(Rational,(Int8,))
new = jl_new_closure(jl_new_struct_internal, R)
R.constructor_defining_closure(R, new)


struct Foo
  ...
  Foo(x) = new(x, 0)
end

struct MySingleton
  ...
  instance = ()
  MySingleton() = is(instance,()) ? (instance=new(...)) : instance
end

if no ctor definitions preset, you get Foo(...) = new(...)

-------------------------------------------------------------------------------

issues 6/21/10

- inference within closures
  * avoid box for variables (arguments) that aren't assigned
    . even better, for variables that are assigned definitely and once
  . then multiple assignments in the binding scope but not in closures
  . then assignments within closures
* inference for new constructor stuff
- hooking up the pieces to use inferred types in the compiler
  . we could save tuples (type_sig, AST) as s-exprs to avoid the cost
    of lowering and type inference.
- make type parameters visible to user-defined constructors
  . in generic case, instantiate all signatures with the typevar mapping
    that's currently created in add_generic_ctor
  . in non-generic case, add static parameters
- limit specialization of vararg functions
- be able to cache results obtained by recursive inference in method
  table cache when appropriate. instead of calling typeinf() recursively,
  call specialize(), which will do something more like cache_method.

- coroutines, Tasks, exceptions
- new for loop, comprehension, reduction formulation

method ordering tests:
//:  (T,T) before (Any,Any)
+:   (T<:Number{T},T<:Number{T}) before (Number{T},Number{T})
promote_type: promote_type(Type{T},Type{T}) first
ref: ref(Array{Any,1},Int32) before ref(Array{T,1},Int32)
